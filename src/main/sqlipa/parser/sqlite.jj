options {
    LOOKAHEAD = 1;
    STATIC = false;
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.5";
    IGNORE_CASE = true ;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.name.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.drop.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;
import main.sqlipa.parser.ast.stmt.event.update.*;
import main.sqlipa.parser.ast.stmt.pragma.*;

final class ASTParser {
    public static void main(String args[]) {
        ASTParser parser = new ASTParser(System.in);
        try {
            parser.sqlStmt();
            System.out.println("Accept");
        } catch (ParseException e) {
            System.out.println("Reject");
        }
    }
} 
PARSER_END(ASTParser)

/* WHITE SPACE */

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* COMMENTS */

TOKEN_MGR_DECLS :
{
    private void CommonTokenAction(Token token) {

    }
}

// Prefixed tokens avoid name collisions.
//
// K_ - Keyword, O_ - Operator, S_ - Substitutes

TOKEN:
{
    <K_ABORT: "ABORT">
|   <K_ACTION: "ACTION">
|   <K_ADD: "ADD">
|   <K_AFTER: "AFTER">
|   <K_ALL: "ALL">
|   <K_ALTER: "ALTER">
|   <K_ANALYZE: "ANALYZE">
|   <K_AND: "AND">
|   <K_AS: "AS">
|   <K_ASC: "ASC">
|   <K_ATTACH: "ATTACH">
|   <K_AUTOINCREMENT: "AUTOINCREMENT">
|   <K_BEFORE: "BEFORE">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN: "BETWEEN">
|   <K_BY: "BY">
|   <K_CASCADE: "CASCADE">
|   <K_CASE: "CASE">
|   <K_CAST: "CAST">
|   <K_CHECK: "CHECK">
|   <K_COLLATE: "COLLATE">
|   <K_COLUMN: "COLUMN">
|   <K_COMMIT: "COMMIT">
|   <K_CONFLICT: "CONFLICT">
|   <K_CONSTRAINT: "CONSTRAINT">
|   <K_CREATE: "CREATE">
|   <K_CROSS: "CROSS">
|   <K_CURRENT_DATE: "CURRENT_DATE">
|   <K_CURRENT_TIME: "CURRENT_TIME">
|   <K_CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <K_DATABASE: "DATABASE">
|   <K_DEFAULT: "DEFAULT">
|   <K_DEFERRABLE: "DEFERRABLE">
|   <K_DEFERRED: "DEFERRED">
|   <K_DELETE: "DELETE">
|   <K_DESC: "DESC">
|   <K_DETACH: "DETACH">
|   <K_DISTINCT: "DISTINCT">
|   <K_DROP: "DROP">
|   <K_EACH: "EACH">
|   <K_ELSE: "ELSE">
|   <K_END: "END">
|   <K_ESCAPE: "ESCAPE">
|   <K_EXCEPT: "EXCEPT">
|   <K_EXCLUSIVE: "EXCLUSIVE">
|   <K_EXISTS: "EXISTS">
|   <K_EXPLAIN: "EXPLAIN">
|   <K_FAIL: "FAIL">
|   <K_FOR: "FOR">
|   <K_FOREIGN: "FOREIGN">
|   <K_FROM: "FROM">
|   <K_FULL: "FULL">
|   <K_GLOB: "GLOB">
|   <K_GROUP: "GROUP">
|   <K_HAVING: "HAVING">
|   <K_IF: "IF">
|   <K_IGNORE: "IGNORE">
|   <K_IMMEDIATE: "IMMEDIATE">
|   <K_IN: "IN">
|   <K_INDEX: "INDEX">
|   <K_INDEXED: "INDEXED">
|   <K_INITIALLY: "INITIALLY">
|   <K_INNER: "INNER">
|   <K_INSERT: "INSERT">
|   <K_INSTEAD: "INSTEAD">
|   <K_INTERSECT: "INTERSECT">
|   <K_INTO: "INTO">
|   <K_IS: "IS">
|   <K_ISNULL: "ISNULL">
|   <K_JOIN: "JOIN">
|   <K_KEY: "KEY">
|   <K_LEFT: "LEFT">
|   <K_LIKE: "LIKE">
|   <K_LIMIT: "LIMIT">
|   <K_MATCH: "MATCH">
|   <K_NATURAL: "NATURAL">
|   <K_NO: "NO">
|   <K_NOT: "NOT">
|   <K_NOTNULL: "NOTNULL">
|   <K_NULL: "NULL">
|   <K_OF: "OF">
|   <K_OFFSET: "OFFSET">
|   <K_ON: "ON">
|   <K_OR: "OR">
|   <K_ORDER: "ORDER">
|   <K_OUTER: "OUTER">
|   <K_PLAN: "PLAN">
|   <K_PRAGMA: "PRAGMA">
|   <K_PRIMARY: "PRIMARY">
|   <K_QUERY: "QUERY">
|   <K_RAISE: "RAISE">
|   <K_REFERENCES: "REFERENCES">
|   <K_REGEXP: "REGEXP">
|   <K_REINDEX: "REINDEX">
|   <K_RELEASE: "RELEASE">
|   <K_RENAME: "RENAME">
|   <K_REPLACE: "REPLACE">
|   <K_RESTRICT: "RESTRICT">
|   <K_RIGHT: "RIGHT">
|   <K_ROLLBACK: "ROLLBACK">
|   <K_ROW: "ROW">
|   <K_SAVEPOINT: "SAVEPOINT">
|   <K_SELECT: "SELECT">
|   <K_SET: "SET">
|   <K_TABLE: "TABLE">
|   <K_TEMP: "TEMP">
|   <K_TEMPORARY: "TEMPORARY">
|   <K_THEN: "THEN">
|   <K_TO: "TO">
|   <K_TRANSACTION: "TRANSACTION">
|   <K_TRIGGER: "TRIGGER">
|   <K_UNION: "UNION">
|   <K_UNIQUE: "UNIQUE">
|   <K_UPDATE: "UPDATE">
|   <K_USING: "USING">
|   <K_VACUUM: "VACUUM">
|   <K_VALUES: "VALUES">
|   <K_VIEW: "VIEW">
|   <K_VIRTUAL: "VIRTUAL">
|   <K_WHEN: "WHEN">
|   <K_WHERE: "WHERE">
}

void sqlStmtList() :{}
{
    (sqlStmt())*
}

SqlStatement sqlStmt() :
{
    Block block = new ExpansibleBlock();
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            block.setBegin(token.beginLine, token.beginColumn);
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    // Each statement function receives a Block to get the begin values in case 
    // the statement doesn't start by EXPLAIN. To get the right values is used 
    // an ExpansibleBlock.
    (
        stmt = alterTableStmt(block)
    |   stmt = analyzeStmt(block)
    |   stmt = attachStmt(block)
	|   stmt = beginStmt(block)
	|   stmt = commitStmt(block)
	|   stmt = createIndexStmt(block)
	|   stmt = createTableStmt(block)
	|   stmt = createTriggerStmt(block)
	|   stmt = createViewStmt(block)
	|   stmt = createVirtualTableStmt(block)	|   stmt = deleteStmt(block)
	|   stmt = deleteStmtLimited(block)
	|   stmt = detachStmt(block)
	|   stmt = dropIndexStmt(block)
	|   stmt = dropTableStmt(block)
	|   stmt = dropTriggerStmt(block)
	|   stmt = dropViewStmt(block)
	|   stmt = insertStmt(block)
	|   stmt = pragmaStmt(block)
	|   stmt = reindexStmt(block)
	|   stmt = releaseStmt(block)
	|   stmt = rollbackStmt(block)
	|   stmt = savepointStmt(block)
	|   stmt = selectStmt(block)
	|   stmt = updateStmt(block)
	|   stmt = updateStmtLimited(block)
	|   stmt = vacuumStmt(block)
	) {
	   block.setEnd(token.endLine, token.endColumn);
	   stmt.setBlock(block);
	   stmt.setExplain(explain);
	   return stmt;
    }
}

SqlStatement alterTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ALTER"
    {
        return stmt;
    }}

SqlStatement analyzeStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ANALYZE"
    {
        return stmt;
    }
}

SqlStatement attachStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ATTACH"
    {
        return stmt;
    }
}

SqlStatement beginStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "BEGIN"
    {
        return stmt;
    }
}

SqlStatement commitStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "COMMIT"
    {
        return stmt;
    }
}

SqlStatement rollbackStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ROLLBACK"
    {
        return stmt;
    }
}

SqlStatement savepointStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "SAVEPOINT"
    {
        return stmt;
    }
}

SqlStatement releaseStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "RELEASE"
    {
        return stmt;
    }
}

SqlStatement createIndexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE INDEX"
    {
        return stmt;
    }
}

void indexedColumn() :
{
}
{
    "b"}

CreateTableStmt createTableStmt(Block block) :
{
    CreateTableStmt stmt;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    DatabaseName db = null;
    TableName tab;
    SelectStmt select = null;}
{
    "CREATE" {
        block.setBegin(token.beginLine, token.beginColumn); 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        db = databaseName() "."
    ]
    tab = tableName()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(tab);
        stmt.setDatabase(db);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
    TableConstraint constraint;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(column);
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHAED(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        "," 
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," 
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmtWithSelect createTableStmtWithSelect() :
{
    SelectStmt select;
}
{
    "AS"
    select = selectStmt(new Block()) {
        return new CreateTableStmtWithSelect(select);
    }
}

ColumnDef columnDef() :
{
    ColumnDef columnDef = new ColumnDef();
    ColumnName column;
    TypeName type = null;
    ColumnConstraint constraint;}
{
    column = columnName()
    [
        type = typeName()
    ]
    (
        constraint = columnConstraint() {
            columnDef.addConstraint(constraint);
        }
    )* {
        columnDef.setBlock(new Block(column.getBeginLine(), 
            column.getBeginColumn(), token.endLine, token.endColumn));
        columnDef.setColumn(column);
        columnDef.setType(type);
        return columnDef;
    }}

TypeName typeName() :
{
    Block block = new Block();
    String name = new String();
    SignedNumber xDim = null;
    SignedNumber yDim = null;}
{
    name() {
        block.setBegin(token.beginLine, token.beginColumn);
        name += token.image;
    }
    (
        name() {
            name += " " + token.image;
        }
    )*
    [
        "("
        xDim = signedNumber() 
        [
            "," 
            yDim = signedNumber()
        ]
        ")"
    ] {
        block.setEnd(token.endLine, token.endColumn);
        return new TypeName(block, name, xDim, yDim);
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    Block block = new ExpansibleBlock();
    ConstraintName name = null;}
{
    [
        "CONSTRAINT" {
            block.setBegin(token.beginLine, token.beginColumn);
        }
        name = constraintName()
    ]
    // Each constraint function receives a Block to get the begin values in case 
    // the constraint doesn't start by CONSTRAINT. To get the right values is 
    // used an ExpansibleBlock.
    (
        constraint = primaryKeyColumnConstraint(block)
    |   constraint = notNullColumnConstraint(block)
    |   constraint = uniqueColumnConstraint(block)
    |   constraint = checkColumnConstraint(block)
    |   constraint = defaultColumnConstraint(block)    |   constraint = collateColumnConstraint(block)
    |   constraint = foreignKeyColumnConstraint(block)
    ) {
        block.setEnd(token.endLine, token.endColumn);
        constraint.setBlock(block);
        constraint.setName(name);
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint(Block block) :
{
    PrimaryKeyColumnConstraint.Order order = null;
    ConflictClause clause;
    boolean hasAutoincrement = false;
}
{
    "PRIMARY" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        (
            "ASC" {
                order = PrimaryKeyColumnConstraint.Order.ASC;
            }
        |   "DESC" {
                order = PrimaryKeyColumnConstraint.Order.DESC;
            }
        )
    ]
    clause = conflictClause()
    [
        "AUTOINCREMENT" {
            hasAutoincrement = true;
        }
    ] {
        return new PrimaryKeyColumnConstraint(order, clause, hasAutoincrement);
    }
}

NotNullColumnConstraint notNullColumnConstraint(Block block) :
{
    ConflictClause clause;
}
{
    "NOT" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    clause = conflictClause() {
        return new NotNullColumnConstraint(clause);
    }
}

UniqueColumnConstraint uniqueColumnConstraint(Block block) :
{
    ConflictClause clause;
}
{
    "UNIQUE" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    clause = conflictClause() {
        return new UniqueColumnConstraint(clause);
    }
}

CheckColumnConstraint checkColumnConstraint(Block block) :
{
    Expression expr;
}
{
    "CHECK" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    expr = expr()
    ")" {
        return new CheckColumnConstraint(expr);
    }
}

DefaultColumnConstraint defaultColumnConstraint(Block block) :
{
    DefaultColumnConstraint constraint;
}
{
    "DEFAULT" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    (
        constraint = numberColumnConstraint()
    |   constraint = literalColumnConstraint()
    |   constraint = expressionColumnConstraint()
    ) {
        return constraint;
    }
}

NumberColumnConstraint numberColumnConstraint():
{
    SignedNumber number;
}
{
    number = signedNumber() {
        return new NumberColumnConstraint(number);
    }
}

LiteralColumnConstraint literalColumnConstraint() :
{
    Literal literal;
}
{
    literal = literalValue() {
        return new LiteralColumnConstraint(literal);
    }
}

ExpressionColumnConstraint expressionColumnConstraint() :
{
    Expression expr;
}
{
    "("
    expr = expr()
    ")" {
        return new ExpressionColumnConstraint(expr);
    }
}

CollateColumnConstraint collateColumnConstraint(Block block) :
{
    CollationName collation;
}
{
    "COLLATE" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    collation = collationName() {
        return new CollateColumnConstraint(collation);
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint(Block block) :
{
    ForeignKeyClause clause;
}
{
    clause = foreignKeyClause() {
        block.setBegin(clause.getBeginLine(), clause.getBeginColumn());
        return new ForeignKeyColumnConstraint(clause);
    }
}

SignedNumber signedNumber() :
{
    Block block = new ExpansibleBlock();
    SignedNumber.Signal sign = null;
    NumericLiteral literal;}
{
    [
        (
            "+" {
                sign = SignedNumber.Signal.PLUS;
            }
        |   "-" {
                sign = SignedNumber.Signal.MINUS;
            }
        ) {
            block.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        block.setValues(literal.getBeginLine(), literal.getBeginColumn(),
            token.endLine, token.endColumn);
        return new SignedNumber(block, sign, literal);
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    Block block = new ExpansibleBlock();
    ConstraintName name = null;
}
{
    [
        "CONSTRAINT" {
            block.setBegin(token.beginLine, token.beginColumn);
        }
        name = name()
    ]
    // Each constraint function receives a Block to get the begin values in case 
    // the constraint doesn't start by CONSTRAINT. To get the right values is 
    // used an ExpansibleBlock.
    (
        constraint = primaryKeyTableConstraint(block)
    |   constraint = checkTableConstraint(block)
    |   constraint = foreignKeyTableConstraint(block)
    ) {
        block.setEnd(token.endLine, token.endColumn);
        constraint.setBlock(block);
        constraint.setName(name);
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint(Block block) :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "PRIMARY" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint(Block block) :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "UNIQUE" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint(Block block) :
{
    Expression expr;
}
{
    "CHECK" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() 
    ")" {
        return new CheckTableConstraint(expr);
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint(Block block) :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    ColumnName column;
    ForeignKeyClause clause;
}
{
    "FOREIGN" {
        block.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = columnName() {
        constraint.addColumn(column);
    }
    (
        "," 
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = foreignKeyClause() {
        constraint.setClause(clause);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{}
{
    "REFERENCES"
    foreignTable()
    ["(" columnName() ("," columnName())* ")"]
    (
        "ON"
        (   
            "DELETE"
        |   "UPDATE")
        (
            "SET" 
            (
              "NULL"
            | "CASCADE"
            )
        |   "CASCADE"
        |   "RESTRICT"
        |   "NO" "ACTION"
        )
    |   "MATCH" name()
    )*
    [LOOKAHEAD(2) ["NOT"] "DEFERRABLE" ["INITIALLY" ("DEFERRED" | "IMMEDIATE")]]
    {
        return null;
    }}

ConflictClause conflictClause() :
{}
{
    [   
        "ON" 
        "CONFLICT"
        (
            "ROLLBACK"
        |   "ABORT"
        |   "FAIL"
        |   "IGNORE"
        |   "REPLACE"
        )
    ] {
        return null;
    }}

SqlStatement createTriggerStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE TRIGGER"
    {
        return stmt;
    }
}

SqlStatement createViewStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIEW"
    {
        return stmt;
    }
}

SqlStatement createVirtualTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIRTUAL"
    {
        return stmt;
    }
}

SqlStatement deleteStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DELETE"
    {
        return stmt;
    }
}

SqlStatement deleteStmtLimited(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DELETE limited"
    {
        return stmt;
    }
}

SqlStatement detachStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DETACH"
    {
        return stmt;
    }
}

SqlStatement dropIndexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP INDEX"
    {
        return stmt;
    }
}

SqlStatement dropTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP TABLE"
    {
        return stmt;
    }
}

SqlStatement dropTriggerStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP TRIGGER"
    {
        return stmt;
    }
}

SqlStatement dropViewStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP VIEW"
    {
        return stmt;
    }
}

Expression expr() :
{}
{
    "c" {
        return null;
    }}

void raiseFunction() :
{}
{
    "d"}

Literal literalValue() :
{}
{
    "a" {
        return null;
    }}

void numericLiteral() :
{}
{
    "e"}

SqlStatement insertStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "INSERT"
    {
        return stmt;
    }
}

SqlStatement pragmaStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "PRAGMA"
    {
        return stmt;
    }
}

void pragmaValue() :
{}
{
    "q"}

SqlStatement reindexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "REINDEX"
    {
        return stmt;
    }
}

SelectStmt selectStmt(Block block) :
{
    SelectStmt stmt = null;
}
{
    "SELECT"
    {
        return stmt;
    }
}


void selectCore() :
{}
{
    "as"}


void resultColumn() :
{}
{
    "d"}

void joinSource() :
{}
{
    "f"}

void singleSource() :
{}
{
    "g"}

void joinOp() :
{}
{
    "h"}

void joinConstraint() :
{}
{
    "j"}

void orderingTerm() :
{}
{
    "k"}

void compoundOperator() :
{}
{
    "l"}

SqlStatement updateStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "UPDATE"
    {
        return stmt;
    }
}

SqlStatement updateStmtLimited(Block block) :
{
    SqlStatement stmt = null;
}
{
    "UPDATE limi"
    {
        return stmt;
    }
}

void qualifiedTableName() :
{}
{
    "m"}

SqlStatement vacuumStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "VACUUM"
    {
        return stmt;
    }
}

// Functions not mentioned in the specification.
DatabaseName databaseName() :
{
}
{
    "w"
    {
        return null;
    }
}

TableName tableName() :
{
}
{
    "e"
    {
        return null;
    }
}

void name() :
{
}
{
    "r"
}

ColumnName columnName() :
{
    
}
{
    "v" {
        return null;
    }
}

void foreignTable() :
{
}
{
    "t"
}

CollationName collationName() :
{
}
{
    "y" {
        return null;
    }
}

ConstraintName constraintName() :
{
}
{
    {
        return null;
    }
}