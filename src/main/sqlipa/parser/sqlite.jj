options {
    STATIC = false;
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.5";
    IGNORE_CASE = true ;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.name.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;

final class ASTParser {

    public static void main(String args[]) {
        ASTParser parser = new ASTParser(System.in);
        try {
            parser.sqlStmt();
            System.out.println("Accept");
        } catch (ParseException e) {
            System.out.println("Reject");
        }
    }

} 
PARSER_END(ASTParser)

/* WHITE SPACE */

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* COMMENTS */

TOKEN_MGR_DECLS :
{
    private void CommonTokenAction(Token token) {

    }
}

// Prefixed tokens avoid name collisions.
//
// K_ - Keyword, O_ - Operator, S_ - Substitutes

TOKEN:
{
    <K_ABORT: "ABORT">
|   <K_ACTION: "ACTION">
|   <K_ADD: "ADD">
|   <K_AFTER: "AFTER">
|   <K_ALL: "ALL">
|   <K_ALTER: "ALTER">
|   <K_ANALYZE: "ANALYZE">
|   <K_AND: "AND">
|   <K_AS: "AS">
|   <K_ASC: "ASC">
|   <K_ATTACH: "ATTACH">
|   <K_AUTOINCREMENT: "AUTOINCREMENT">
|   <K_BEFORE: "BEFORE">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN: "BETWEEN">
|   <K_BY: "BY">
|   <K_CASCADE: "CASCADE">
|   <K_CASE: "CASE">
|   <K_CAST: "CAST">
|   <K_CHECK: "CHECK">
|   <K_COLLATE: "COLLATE">
|   <K_COLUMN: "COLUMN">
|   <K_COMMIT: "COMMIT">
|   <K_CONFLICT: "CONFLICT">
|   <K_CONSTRAINT: "CONSTRAINT">
|   <K_CREATE: "CREATE">
|   <K_CROSS: "CROSS">
|   <K_CURRENT_DATE: "CURRENT_DATE">
|   <K_CURRENT_TIME: "CURRENT_TIME">
|   <K_CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <K_DATABASE: "DATABASE">
|   <K_DEFAULT: "DEFAULT">
|   <K_DEFERRABLE: "DEFERRABLE">
|   <K_DEFERRED: "DEFERRED">
|   <K_DELETE: "DELETE">
|   <K_DESC: "DESC">
|   <K_DETACH: "DETACH">
|   <K_DISTINCT: "DISTINCT">
|   <K_DROP: "DROP">
|   <K_EACH: "EACH">
|   <K_ELSE: "ELSE">
|   <K_END: "END">
|   <K_ESCAPE: "ESCAPE">
|   <K_EXCEPT: "EXCEPT">
|   <K_EXCLUSIVE: "EXCLUSIVE">
|   <K_EXISTS: "EXISTS">
|   <K_EXPLAIN: "EXPLAIN">
|   <K_FAIL: "FAIL">
|   <K_FOR: "FOR">
|   <K_FOREIGN: "FOREIGN">
|   <K_FROM: "FROM">
|   <K_FULL: "FULL">
|   <K_GLOB: "GLOB">
|   <K_GROUP: "GROUP">
|   <K_HAVING: "HAVING">
|   <K_IF: "IF">
|   <K_IGNORE: "IGNORE">
|   <K_IMMEDIATE: "IMMEDIATE">
|   <K_IN: "IN">
|   <K_INDEX: "INDEX">
|   <K_INDEXED: "INDEXED">
|   <K_INITIALLY: "INITIALLY">
|   <K_INNER: "INNER">
|   <K_INSERT: "INSERT">
|   <K_INSTEAD: "INSTEAD">
|   <K_INTERSECT: "INTERSECT">
|   <K_INTO: "INTO">
|   <K_IS: "IS">
|   <K_ISNULL: "ISNULL">
|   <K_JOIN: "JOIN">
|   <K_KEY: "KEY">
|   <K_LEFT: "LEFT">
|   <K_LIKE: "LIKE">
|   <K_LIMIT: "LIMIT">
|   <K_MATCH: "MATCH">
|   <K_NATURAL: "NATURAL">
|   <K_NO: "NO">
|   <K_NOT: "NOT">
|   <K_NOTNULL: "NOTNULL">
|   <K_NULL: "NULL">
|   <K_OF: "OF">
|   <K_OFFSET: "OFFSET">
|   <K_ON: "ON">
|   <K_OR: "OR">
|   <K_ORDER: "ORDER">
|   <K_OUTER: "OUTER">
|   <K_PLAN: "PLAN">
|   <K_PRAGMA: "PRAGMA">
|   <K_PRIMARY: "PRIMARY">
|   <K_QUERY: "QUERY">
|   <K_RAISE: "RAISE">
|   <K_REFERENCES: "REFERENCES">
|   <K_REGEXP: "REGEXP">
|   <K_REINDEX: "REINDEX">
|   <K_RELEASE: "RELEASE">
|   <K_RENAME: "RENAME">
|   <K_REPLACE: "REPLACE">
|   <K_RESTRICT: "RESTRICT">
|   <K_RIGHT: "RIGHT">
|   <K_ROLLBACK: "ROLLBACK">
|   <K_ROW: "ROW">
|   <K_SAVEPOINT: "SAVEPOINT">
|   <K_SELECT: "SELECT">
|   <K_SET: "SET">
|   <K_TABLE: "TABLE">
|   <K_TEMP: "TEMP">
|   <K_TEMPORARY: "TEMPORARY">
|   <K_THEN: "THEN">
|   <K_TO: "TO">
|   <K_TRANSACTION: "TRANSACTION">
|   <K_TRIGGER: "TRIGGER">
|   <K_UNION: "UNION">
|   <K_UNIQUE: "UNIQUE">
|   <K_UPDATE: "UPDATE">
|   <K_USING: "USING">
|   <K_VACUUM: "VACUUM">
|   <K_VALUES: "VALUES">
|   <K_VIEW: "VIEW">
|   <K_VIRTUAL: "VIRTUAL">
|   <K_WHEN: "WHEN">
|   <K_WHERE: "WHERE">
}

/*TOKEN:
{
    <O_CONCATENATION: "||">
|   <O_MULTIPLICATION: "*">
|   <O_DIVISION: "/">
|   <O_MODULO: "%">
|   <O_ADDITION: "+">
|   <O_SUBTRACTION: "-">
|   <O_SHIFT_HIGH: "<<">
|   <O_SHIFT_LOW: ">>">
|   <O_BITWISE_AND: "&">
|   <O_BITWISE_OR: "|">
|   <O_LESS: "<">
|   <O_LESS_OR_EQUAL: "<=">
|   <O_GREATER: ">">
|   <O_GREATER_OR_EQUAL: ">=">
|   <O_EQUAL: "=" | "==">
|   <O_NOT_EQUAL: "!=" | "<>">
}*/

void sqlStmtList() :{}
{
    (sqlStmt())*
}

SqlStatement sqlStmt() :
{
    int line = 0;
    int column = 0;
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            line = token.beginLine;
            column = token.beginColumn;
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    (/*
        stmt = alterTableStmt()
    |   stmt = analyzeStmt()
    |   stmt = attachStmt()
	|   stmt = beginStmt()
	|   stmt = commitStmt()
	|   stmt = createIndexStmt()
	|*/   stmt = createTableStmt() /*
	|   stmt = createTriggerStmt()
	|   stmt = createViewStmt()
	|   stmt = createVirtualTableStmt()	|   stmt = deleteStmt()
	|   stmt = deleteStmtLimited()
	|   stmt = detachStmt()
	|   stmt = dropIndexStmt()
	|   stmt = dropTableStmt()
	|   stmt = dropTriggerStmt()
	|   stmt = dropViewStmt()
	|   stmt = insertStmt()
	|   stmt = pragmaStmt()
	|   stmt = reindexStmt()
	|   stmt = releaseStmt()
	|   stmt = rollbackStmt()
	|   stmt = savepointStmt()
	|*/   stmt = selectStmt() /*
	|   stmt = updateStmt()
	|   stmt = updateStmtLimited()
	|   stmt = vacuumStmt()*/
	) {
        if (explain != null) {
            // If statement starts by EXPLAIN.
            stmt.setBegin(line, column);
            stmt.setExplain(explain);
        }
        return stmt;
    }
}

IndexedColumn indexedColumn() :
{
    IndexedColumn indColumn = new IndexedColumn();
    ColumnName column;
}
{
    column = columnName() {
        indColumn.setColumn(column);
        indColumn.setBegin(column);
    }
    [
        "COLLATE" {
            CollationName collation;
        }
        collation = collationName() {
            indColumn.setCollation(collation);
        }
    ]
    [
        "ASC" {
            indColumn.setOrder(IndexedColumn.Order.ASC);
        }
    |   "DESC" {
            indColumn.setOrder(IndexedColumn.Order.DESC);
        }
    ] {
        indColumn.setEnd(token.endLine, token.endColumn);
        return indColumn;
    }}

CreateTableStmt createTableStmt() :
{
    CreateTableStmt stmt;
    int line;
    int column;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    DatabaseName db = null;
    TableName tab;
}
{
    "CREATE" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        db = databaseName() "."
    ]
    tab = tableName()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.setTemporary(hasTemp);
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(tab);
        stmt.setDatabase(db);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(columnDef());
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHAED(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        "," 
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," {
            TableConstraint constraint;
        }
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmtWithSelect createTableStmtWithSelect() :
{
    SelectStmt select;
}
{
    "AS"
    select = selectStmt() {
        return new CreateTableStmtWithSelect(select);
    }
}

ColumnDef columnDef() :
{
    ColumnDef columnDef = new ColumnDef();
    ColumnName column;
    TypeName type;
    ColumnConstraint constraint;}
{
    column = columnName() {
        columnDef.setColumn(column);
        columnDef.setBegin(column);
    }
    [
        type = typeName() {
            columnDef.setType(type);
        }
    ]
    (
        constraint = columnConstraint() {
            columnDef.addConstraint(constraint);
        }
    )* {
        columnDef.setEnd(token.endLine, token.endColumn);
        return columnDef;
    }}

TypeName typeName() :
{
    TypeName type = new TypeName();
    String name = new String();
    
    type.setName(name);}
{
    name() {
        // TODO: name must return.
        type.setBegin(token.beginLine, token.beginColumn);
        name += token.image;
    }
    (
        name() {
            name += " " + token.image;
        }
    )*
    [
        "(" {
            SignedNumber xDim;
        }
        xDim = signedNumber() {
            type.setDimensionInX(xDim);
        }
        [
            "," {
                SignedNumber yDim;
            }
            yDim = signedNumber() {
                type.setDimensionInY(yDim);
            }
        ]
        ")"
    ] {
        type.setEnd(token.endLine, token.endColumn);
        return type;
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    int line = 0;
    int column = 0;
    ConstraintName name = null;}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyColumnConstraint()
    |   constraint = notNullColumnConstraint()
    |   constraint = uniqueColumnConstraint()
    |   constraint = checkColumnConstraint()
    |   constraint = defaultColumnConstraint()    |   constraint = collateColumnConstraint()
    |   constraint = foreignKeyColumnConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint() :
{
    PrimaryKeyColumnConstraint constraint = new PrimaryKeyColumnConstraint();
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        "ASC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.ASC);
        }
    |   "DESC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.DESC);
        }
    ]
    clause = conflictClause() {
        constraint.setClause(clause);
    }
    [
        "AUTOINCREMENT" {
            constraint.setAutoincrement(true);
        }
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

NotNullColumnConstraint notNullColumnConstraint() :
{
    NotNullColumnConstraint constraint = new NotNullColumnConstraint();
    ConflictClause clause;
}
{
    "NOT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueColumnConstraint uniqueColumnConstraint() :
{
    UniqueColumnConstraint constraint = new UniqueColumnConstraint();
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckColumnConstraint checkColumnConstraint() :
{
    CheckColumnConstraint constraint = new CheckColumnConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    expr = expr()
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

DefaultColumnConstraint defaultColumnConstraint() :
{
    DefaultColumnConstraint constraint;
    int line;
    int column;
}
{
    "DEFAULT" {
        line = token.beginLine;
        column = token.beginColumn;
    }
    (
        constraint = numberColumnConstraint()
    |   constraint = literalColumnConstraint()
    |   constraint = expressionColumnConstraint()
    ) {
        constraint.setBegin(line, column);
        return constraint;
    }
}

NumberColumnConstraint numberColumnConstraint():
{
    NumberColumnConstraint constraint = new NumberColumnConstraint();
    SignedNumber number;
}
{
    number = signedNumber() {
        constraint.setBeginEnd(number);
        constraint.setNumber(number);
        return constraint;
    }
}

LiteralColumnConstraint literalColumnConstraint() :
{
    LiteralColumnConstraint constraint = new LiteralColumnConstraint();
    Literal literal;
}
{
    literal = literalValue() {
        constraint.setBeginEnd(literal);
        constraint.setLiteral(literal);
        return constraint;
    }
}

ExpressionColumnConstraint expressionColumnConstraint() :
{
    ExpressionColumnConstraint constraint = new ExpressionColumnConstraint();
    Expression expr;
}
{
    "(" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr()
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        constraint.setExpression(expr);
        return constraint;
    }
}

CollateColumnConstraint collateColumnConstraint() :
{
    CollateColumnConstraint constraint = new CollateColumnConstraint();
    CollationName collation;
}
{
    "COLLATE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    collation = collationName() {
        constraint.setCollation(collation);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint() :
{
    ForeignKeyColumnConstraint constraint = new ForeignKeyColumnConstraint();
    ForeignKeyClause clause;
}
{
    clause = foreignKeyClause() {
        constraint.setBeginEnd(clause);
        constraint.setClause(clause);
        return constraint;
    }
}

SignedNumber signedNumber() :
{
    SignedNumber number = new SignedNumber();
    NumericLiteral literal;}
{
    [
        (
            "+" {
                number.setSign(SignedNumber.Sign.PLUS);
            }
        |   "-" {
                number.setSign(SignedNumber.Sign.MINUS);
            }
        ) {
            number.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        if (number.getSign() == null) {
            number.setBeginEnd(literal);
        } else {
            number.setEnd(token.endLine, token.endColumn);
        }
        number.setLiteral(literal);
        return number;
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    int line = 0;
    int column = 0;
    ConstraintName name = null;
}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyTableConstraint()
    |   constraint = checkTableConstraint()
    |   constraint = foreignKeyTableConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint() :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint() :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint() :
{
    CheckTableConstraint constraint = new CheckTableConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() 
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint() :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    ColumnName column;
    ForeignKeyClause clause;
}
{
    "FOREIGN" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = columnName() {
        constraint.addColumn(column);
    }
    (
        "," 
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = foreignKeyClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{
    ForeignKeyClause clause = new ForeignKeyClause();
    Block block = new Block();
    TableName tab;
    ForeignKeySetting sett;}
{
    "REFERENCES" {
        clause.setBegin(token.beginLine, token.beginColumn);
    }
    tab = foreignTable() {
        clause.setTable(tab);
    }
    [
        "(" {
            ColumnName column;
        }
        column = columnName() {
            clause.addColumn(column);
        }
        (
            ","
            column = columnName() {
                clause.addColumn(column);
            }
        )*
        ")"
    ]
    (
        sett = onForeignKeySett() {
            clause.addSetting(sett);
        }
    |   sett = matchForeignKeySett() {
            clause.addSetting(sett);
        }
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
        sett = deferrableForeignKeySett() {
            clause.addSetting(sett);
        }
    ] {
        clause.setEnd(token.endLine, token.endColumn);
        return clause;
    }}

OnForeignKeySett onForeignKeySett() :
{
    OnForeignKeySett sett = new OnForeignKeySett();
}
{
    "ON" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    (
        "DELETE" {
            sett.setEvent(OnForeignKeySett.Event.DELETE);
        }
    |   "UPDATE" {
            sett.setEvent(OnForeignKeySett.Event.UPDATE);
        }
    )
    (
        "SET" // SET merged to remove ambiguity.
        (
            "NULL" {
                sett.setAction(OnForeignKeySett.Action.SET_NULL);
            }
        |   "DEFAULT" {
                sett.setAction(OnForeignKeySett.Action.SET_DEFAULT);
            }
        )
    |   "CASCADE" {
            sett.setAction(OnForeignKeySett.Action.CASCADE);
        }
    |   "RESTRICT" {
            sett.setAction(OnForeignKeySett.Action.RESTRICT);
        }
    |   "NO" "ACTION" {
            sett.setAction(OnForeignKeySett.Action.NO_ACTION);
        }
    ) {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

MatchForeignKeySett matchForeignKeySett() :
{
    MatchForeignKeySett sett = new MatchForeignKeySett();
    Name name;
}
{
    "MATCH" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    name = name() {
        sett.setName(name);
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

DeferrableForeignKeySett deferrableForeignKeySett() :
{
    DeferrableForeignKeySett sett = new DeferrableForeignKeySett();
}
{
    (
        "NOT" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.NOT_DEFERRABLE);
        }
        "DEFERRABLE"
    |   "DEFERRABLE" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.DEFERRABLE);
        }
    )
    [
        "INITIALLY"
        (
            "DEFERRED" {
                sett.setMode(DeferrableForeignKeySett.Mode.DEFERRED);
            }
        |   "IMMEDIATE" {
                sett.setMode(DeferrableForeignKeySett.Mode.IMMEDIATE);
            }
        )
    ] {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

ConflictClause conflictClause() :
{
}
{
    [   
        "ON" {
            ConflictClause clause = new ConflictClause();
            clause.setBegin(token.beginLine, token.beginColumn);
        }
        "CONFLICT"
        (
            "ROLLBACK" {
                clause.setAction(ConflictClause.Action.ROLLBACK);
            }
        |   "ABORT" {
                clause.setAction(ConflictClause.Action.ABORT);
            }
        |   "FAIL" {
                clause.setAction(ConflictClause.Action.FAIL);
            }
        |   "IGNORE" {
                clause.setAction(ConflictClause.Action.IGNORE);
            }
        |   "REPLACE" {
                clause.setAction(ConflictClause.Action.REPLACE);
            }
        ) {
            clause.setEnd(token.endLine, token.endColumn);
            return clause;
        }
    ] {
        return null;
    }}
/*
%right BITNOT.*/


// Expression is built to ensure that precedences are maintained as specified
// from the lowest precedence operator "OR" to the highest "COLLATE".
Expression expr() :
{
    Expression left;
    Expression right;
}
{
    left = andExpr()   
    (
        "OR"
        right = andExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.OR);
        }
    )* {
        return left;
    }
}

Expression andExpr() :
{
    Expression left;
    Expression right;
}
{
    left = notExpr()
    (
        "AND"
        right = notExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.AND);
        }
    )* {
        return left;
    }
}

Expression notExpr() :
{
    Expression expr;
}
{
    (
        "NOT" {
            int line = token.beginLine;
            int column = token.beginColumn;
        }
        expr = notExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), UnaryExpr.Operator.LOGICAL_NOT, expr);
        }
    |   expr = equalityExpr() 
    ) {
        return expr;
    }
}

Expression equalityExpr() :
{
    Expression expr;
}
{
    expr = relationalExpr()
    // All types of expressions in choice point can start by "NOT". LOOKAHEAD
    // removes ambiguity in the grammar rule decision.
    (
        LOOKAHEAD(2)
        expr = unaryEqualityExpr(expr)
    |   LOOKAHEAD(2)
        expr = betweenExpr(expr)
    |   LOOKAHEAD(2)
        expr = inExpr(expr)
    |   expr = binaryEqualityExpr(expr)
    )* {
        return expr;
    }
}

Expression unaryEqualityExpr(Expression expr) :
{
    UnaryExpr.Operator op;
}
{
    (
        "ISNULL" {
            op = UnaryExpr.Operator.IS_NULL;
        }
    |   "NOTNULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    |   "NOT" "NULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    ) {
        return new UnaryExpr(new Block(expr.beginLine, expr.beginColumn,
            token.endLine, token.endColumn), op, expr);
    }
}

Expression binaryEqualityExpr(Expression left) :
{
    Expression right;
    BinaryExpr.Operator op;
}
{
    op = binaryEqualityOperator()
    right = relationalExpr() {
        return new BinaryExpr(new Block(left.beginLine, left.beginColumn,
            token.endLine, token.endColumn), left, right, op);
    }
}

BinaryExpr.Operator binaryEqualityOperator() :
{
}
{
    "=" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "==" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "!=" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "<>" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "IS"
    [
        "NOT" {
            return BinaryExpr.Operator.IS_NOT;
        }
    ] {
        return BinaryExpr.Operator.IS;
    }
|   "NOT"
    (
        "LIKE" {
            return BinaryExpr.Operator.NOT_LIKE;
        }
    |   "GLOB" {
            return BinaryExpr.Operator.NOT_GLOB;
        }
    |   "REGEXP" {
            return BinaryExpr.Operator.NOT_REGEXP;
        }
    |   "MATCH" {
            return BinaryExpr.Operator.NOT_MATCH;
        }
    )
|   "LIKE" {
        return BinaryExpr.Operator.LIKE;
    }
|   "GLOB" {
        return BinaryExpr.Operator.GLOB;
    }
|   "REGEXP" {
        return BinaryExpr.Operator.REGEXP;
    }
|   "MATCH" {
        return BinaryExpr.Operator.MATCH;
    }
}

BetweenExpr betweenExpr(Expression expr) :
{
    BetweenExpr between = new BetweenExpr();
    
    between.setExpression(expr);
    between.setBegin(expr);
}
{
    (
        "NOT" "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.NOT_BETWEEN);
        }
    |   "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.BETWEEN);
        }
    )
    expr = relationalExpr() {
        between.setLower(expr);
    }
    "AND"
    expr = relationalExpr() {
        between.setUpper(expr);
        between.setEnd(token.endLine, token.endColumn);
        return between;
    }
}

InExpr inExpr(Expression expr) :
{
    InExpr in = null;
    InExpr.Operator op;
}
{
    (
        "NOT" "IN" {
            op = InExpr.Operator.NOT_IN;
        }
    |   "IN" {
            op = InExpr.Operator.IN;
        }
    )
    (
        "("
        [
            in = inSelectExpr()
        |   in = inSetExpr()
        ] {
            if (in == null) {
                in = new InSetExpr();
            }
        }
        ")"
    |   in = inTableExpr()
    ) {
        in.setExpression(expr);
        in.setOperator(op);
        in.setBegin(expr);
        in.setEnd(token.endLine, token.endColumn);
        return in;
    }
}

InSelectExpr inSelectExpr() :
{
    SelectStmt stmt;
}
{
    stmt = selectStmt() {
        InSelectExpr in = new InSelectExpr();
        in.setStatement(stmt);
        return in;
    }
}

InSetExpr inSetExpr() :
{
    InSetExpr in = new InSetExpr();
    Expression expr;
}
{
    expr = expr() {
        in.addExpression(expr);
    }
    (
        ","
        expr = expr() {
            in.addExpression(expr);
        }
    )* {
        return in;
    }
}

InTableExpr inTableExpr() :
{
    InTableExpr in = new InTableExpr();
    DatabaseName db = null;
    TableName tab;
}
{
    [
        db = databaseName() {
            in.setDatabase(db);
        }
        "."
    ]
    tab = tableName() {
        in.setTable(tab);
        return in;
    }
}

Expression relationalExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = escapeExpr()
    (
        (
            "<" {
                op = BinaryExpr.Operator.LESS;
            }
        |   "<=" {
                op = BinaryExpr.Operator.LESS_OR_EQUAL;
            }
        |   ">" {
                op = BinaryExpr.Operator.GREATER;
            }
        |   ">=" {
                op = BinaryExpr.Operator.GREATER_OR_EQUAL;
            }
        )
        right = escapeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression escapeExpr() :
{
    Expression left;
    Expression right;
}
{
    left = bitwiseExpr()
    [
        "ESCAPE"
        right = bitwiseExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.ESCAPE);
        }
    ] {
        return left;
    }
}

Expression bitwiseExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = additiveExpr()
    (
        op = bitwiseOperator()
        right = additiveExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

BinaryExpr.Operator bitwiseOperator() :
{
}
{
    ">>" {
        return BinaryExpr.Operator.SHIFT_HIGH;
    }
|   "<<" {
        return BinaryExpr.Operator.SHIFT_LOW;
    }
|   "&" {
        return BinaryExpr.Operator.BITWISE_AND;
    }
|   "|" {
        return BinaryExpr.Operator.BITWISE_OR;
    }
}

Expression additiveExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = multiplicativeExpr()
    (
        (
            "+" {
                op = BinaryExpr.Operator.ADDITION;
            }
        |   "-" {
                op = BinaryExpr.Operator.SUBTRACTION;
            }
        )
        right = multiplicativeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression multiplicativeExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = concatenateExpr()
    (
        (
            "*" {
                op = BinaryExpr.Operator.MULTIPLICATION;
            }
        |   "/" {
                op = BinaryExpr.Operator.DIVISION;
            }
        |   "%" {
                op = BinaryExpr.Operator.MODULO;
            }
        )
        right = concatenateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression concatenateExpr() :
{
    Expression left;
    Expression right;
}
{
    left = collateExpr()
    (
        "||"
        right = collateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.CONCATENATION);
        }
    )* {
        return left;
    }
}

Expression collateExpr() :
{
    Expression expr;
    CollationName collation;
}
{
    expr = unaryExpr()
    (
        "COLLATE"
        collation = collationName() {
            expr = new CollateExpr(new Block(expr.beginLine, expr.beginColumn,
                token.endLine, token.endColumn), expr, collation);
        }
    )* {
        return expr;
    }
}

Expression unaryExpr() :
{
    Expression expr;
    UnaryExpr.Operator op;
}
{
    (   
	    op = unaryOperator() {
	        int line = token.beginLine;
	        int column = token.beginColumn;
	    }
        expr = unaryExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), op, expr);
        }
    |   expr = nonLeftRecursiveExpr()
    ) {
        return expr;
    }
}

UnaryExpr.Operator unaryOperator() :
{
}
{
    "-" {
        return UnaryExpr.Operator.NEGATIVE;
    }
|   "+" {
        return UnaryExpr.Operator.POSITIVE;
    }
|   "~" {
        return UnaryExpr.Operator.BITWISE_NOT;
    }
}

Expression nonLeftRecursiveExpr() :
{
    Expression expr;
}
{
    (
        expr = literalExpr()
    |   expr = bindParameterExpr()
    |   expr = columnReferenceExpr()
    //|   expr = functionExpr()
    |   expr = castExpr()
    |   LOOKAHEAD(3)
        expr = existsExpr()
    |   "(" expr = expr() ")"
    |   expr = caseExpr()
    |   expr = raiseFunctionExpr()
    ) {
        return expr;
    }
}

LiteralExpr literalExpr() :
{
    Literal literal;
}
{
    literal = literalValue() {
        return new LiteralExpr(new Block(literal), literal);
    }
}

BindParameterExpr bindParameterExpr() :
{
}
{
    "bindParameter"//bindParameter()
    {
        return null;
    }
}

ColumnReferenceExpr columnReferenceExpr() :
{
    ColumnReferenceExpr reference = new ColumnReferenceExpr();
    DatabaseName db = null;
    TableName tab = null;
    ColumnName column;
}
{
    [
        [
            db = databaseName() {
                reference.setDatabase(db);
                reference.setBegin(db);
            }
            "."
        ]
        tab = tableName() {
            reference.setTable(tab);
            if (db == null) {
                reference.setBegin(tab);
            }
        }
        "."
    ]
    column = columnName() {
        reference.setColumn(column);
        if (column == null) {
            reference.setBegin(column);
        }
        reference.setEnd(token.endLine, token.endColumn);
        return reference;
    }
}


FunctionExpr functionExpr() :
{
}
{
    functionName()
    "("
    // TODO: see better.
    [
        (
            "*"
        |   [ "DISTINCT" ]
            expr()
            (
                ","
                expr()
            )*
        )
    ]
    ")" {
        return null;
    }
}

CastExpr castExpr() :
{
    CastExpr cast = new CastExpr();
    Expression expr;
    TypeName type;
}
{
    "CAST" {
        cast.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() {
        cast.setExpression(expr);
    }
    "AS"
    type = typeName() {
        cast.setType(type);
    }
    ")" {
        cast.setEnd(token.endLine, token.endColumn);
        return cast;
    }
}


UnaryExpr existsExpr() :
{
}
{
    [
        "EXISTS"
    ]
    selectExpr() {
        return null;
    }
}

SelectExpr selectExpr() :
{
}
{
    "("
    selectStmt()
    ")" {
        return null;
    }
}

CaseExpr caseExpr() :
{
    CaseExpr caseExpr = new CaseExpr();
    Expression expr;
    WhenExpr when;
}
{
    "CASE" {
        caseExpr.setBegin(token.beginLine, token.beginColumn);
    }
    [
        expr = expr() {
            caseExpr.setCase(expr);
        }
    ]
    (
        when = whenExpr() {
            caseExpr.addWhen(when);
        }
    )+
    [
        "ELSE"
        expr = expr() {
            caseExpr.setElse(expr);
        }
    ]
    "END" {
        caseExpr.setEnd(token.endLine, token.endColumn);
        return caseExpr;
    }
}

WhenExpr whenExpr() :
{
    WhenExpr when = new WhenExpr();
    Expression expr;
}
{
    "WHEN" {
        when.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        when.setWhen(expr);
    }
    "THEN"
    expr = expr() {
        when.setThen(expr);
        when.setEnd(token.endLine, token.endColumn);
        return when;
    }
}

RaiseFunctionExpr raiseFunctionExpr() :
{
    RaiseFunctionExpr expr = new RaiseFunctionExpr();
}
{
    "RAISE" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    (
        "IGNORE" {
            expr.setType(RaiseFunctionExpr.Type.IGNORE);
        }
    |   (
            "ROLLBACK" {
                expr.setType(RaiseFunctionExpr.Type.ROLLBACK);
            }
        |   "ABORT" {
                expr.setType(RaiseFunctionExpr.Type.ABORT);
            }
        |   "FAIL" {
                expr.setType(RaiseFunctionExpr.Type.FAIL);
            }
        )
        ","
        //errorMessage()
    )
    ")" {
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

Literal literalValue() :
{}
{
    "literalVa" {
        return null;
    }}

NumericLiteral numericLiteral() :
{}
{
    "numericLi" {
        return null;
    }}

SelectStmt selectStmt() :
{
    SelectStmt stmt = new SelectStmt();
    SelectUnit unit;
    SelectCompound.Operator op;
    SelectUnit core;
}
{
    unit = selectCore() {
        stmt.setBegin(unit);
    }
    (
        op = compoundOperator()
        core = selectCore() {
            unit = new SelectCompound(new Block(unit.beginLine, 
                unit.beginColumn, token.endLine, token.endColumn), unit, core,
                op);
        }
    )* {
        stmt.setUnit(unit);
    }
    [
        "ORDER" "BY" {
            OrderingTerm term;
        }
        term = orderingTerm() {
            stmt.addTerm(term);
        }
        (
            ","
            term = orderingTerm() {
                stmt.addTerm(term);
            }
        )*
    ]
    [
        "LIMIT" {
            Expression expr;
        }
        expr = expr() {
            stmt.setLimit(expr);
        }
        [
            ( "OFFSET" | "," )
            expr = expr() {
                stmt.setOffset(expr);
            }
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}


SelectCore selectCore() :
{
    SelectCore core = new SelectCore();
    ResultColumn column;}
{
    "SELECT" {
        core.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DISTINCT" {
            core.setDistinct(true);
        }
    |   "ALL"
    ]
    column = resultColumn() {
        core.addColumn(column);
    }
    (
        ","
        resultColumn() {
	        core.addColumn(column);
	    }
    )*
    [
        "FROM" {
            JoinSrc src;
        }
        src = joinSource() {
            core.setFrom(src);
        }
    ]
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            core.setWhere(expr);
        }
    ]
    [
        "GROUP" "BY" {
            Expression expr;
        }
        expr = expr() {
            core.addGroupByExpression(expr);
        }
        (
            ","
            expr = expr() {
                core.addGroupByExpression(expr);
            }
        )*
        [
            "HAVING"
            expr = expr() {
                core.setHaving(expr);
            }
        ]
    ] {
        core.setEnd(token.endLine, token.endColumn);
        return core;
    }
}

ResultColumn resultColumn() :
{
    ResultColumn column;}
{
    (
        column = universalColumn()
    |   column = expressionColumn()
    ) {
        return column;
    }}

UniversalColumn universalColumn() :
{
    UniversalColumn column = new UniversalColumn();
    TableName tab;
}
{
    (
        "*" {
            column.setBeginEnd(token.beginLine, token.beginColumn,
                token.endLine, token.endColumn);
        }
    |   tab = tableName() {
            column.setTable(tab);
        }
        "." 
        "*" {
            column.setBeginEnd(tab.beginLine, tab.beginColumn, token.endLine,
                token.endColumn);
        }
    ) {
        return column;
    }
}

ExpressionColumn expressionColumn() :
{
    ExpressionColumn column = null;
    Expression expr;
}
{
    expr = expr()
    [
        column = aliasedColumn()
    ] {
        if (column == null) {
            column = new ExpressionColumn();
        }
        column.setExpression(expr);
        column.setBeginEnd(expr.beginLine, expr.beginColumn, token.endLine,
            token.endColumn);
        return column;
    }
}

AliasedColumn aliasedColumn() :
{
    AliasedColumn column = new AliasedColumn();
    ColumnAlias alias;
}
{
	[ "AS" ]
	alias = columnAlias() {
	    column.setAlias(alias);
	    return column;
	}
}

JoinSrc joinSource() :
{
    JoinSrc src;
    JoinCompound.Operator op;
    JoinSrc right;
    JoinConstraint constraint;}
{
    src = singleSource()
    (
        op = joinOp()
        right = singleSource()
        constraint = joinConstraint() {
            src = new JoinCompound(new Block(src.beginLine, src.beginColumn,
                token.endLine, token.endColumn), src, right, op, constraint);
        }
    )* {
        return src;
    }}

JoinSrc singleSource() :
{
    JoinSrc src;
    int line = 0;
    int column = 0;}
{
    (
        src = tableSource()
    |   // To remove ambiguity between selectSource and the joinSource because 
        // both start by "(".
        LOOKAHEAD(2)
        src = selectSource()
    |   "(" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        src = joinSource()
        ")" {
            src.setBeginEnd(line, column, token.endLine, token.endColumn);
        }
    ) {
        return src;
    }}

TableSrc tableSource() :
{
    TableSrc src = new TableSrc();
    DatabaseName db = null;
    TableName tab;
    IndexedBy indexed;
}
{
    [
        db = databaseName() {
            src.setDatabase(db);
            src.setBegin(db);
        }
        "."
    ]
    tab = tableName() {
        src.setTable(tab);
        if (db == null) {
            src.setBegin(tab);
        }
    }
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ]
    indexed = indexedBy() {
        src.setIndexed(indexed);
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

SelectSrc selectSource() :
{
    SelectSrc src = new SelectSrc();
    SelectStmt stmt;
}
{
    "(" {
        src.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt() {
        src.setStatement(stmt);
    }
    ")"
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ] {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

JoinCompound.Operator joinOp() :
{}
{
    "," {
        return JoinCompound.Operator.COMMA;
    }
|   "NATURAL" 
    (
        "LEFT" 
        (
            "OUTER" "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_OUTER_JOIN;	        }
	    |   "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_JOIN;
	        }
        )
    |   "INNER" "JOIN" {
            return JoinCompound.Operator.NATURAL_INNER_JOIN;
        }
    |   "CROSS" "JOIN" {
            return JoinCompound.Operator.NATURAL_CROSS_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.NATURAL_JOIN;
        }
    )
|   "LEFT" 
    (
        "OUTER" "JOIN" {
            return JoinCompound.Operator.LEFT_OUTER_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.LEFT_JOIN;
        }
    )
|   "INNER" "JOIN" {
        return JoinCompound.Operator.INNER_JOIN;
    }
|   "CROSS" "JOIN" {
        return JoinCompound.Operator.CROSS_JOIN;
    }
|   "JOIN" {
        return JoinCompound.Operator.JOIN;
    }
}

JoinConstraint joinConstraint() :
{
    JoinConstraint constraint = null;}
{
    [
        constraint = joinConstraintOn()
    |   constraint = joinConstraintUsing()
    ] {
        return constraint;
    }}

JoinConstraintOn joinConstraintOn() :
{
    JoinConstraintOn constraint = new JoinConstraintOn();
    Expression expr;
}
{
    "ON" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

JoinConstraintUsing joinConstraintUsing():
{
    JoinConstraintUsing constraint = new JoinConstraintUsing();
    ColumnName column;
}
{
    "USING" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
	"("
	column = columnName() {
        constraint.addColumn(column);
    }
    (
        ","
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

OrderingTerm orderingTerm() :
{
    OrderingTerm term = new OrderingTerm();
    Expression expr;}
{
    expr = expr() {
        term.setBegin(expr);
        term.setExpression(expr);
    }
    [
        "ASC" {
            term.setOrder(OrderingTerm.Order.ASC);
        }
    |   "DESC" {
            term.setOrder(OrderingTerm.Order.DESC);
        }
    ] {
        term.setEnd(token.endLine, token.endColumn);
        return term;
    }}

SelectCompound.Operator compoundOperator() :
{
}
{
    "UNION" 
    [ 
        "ALL" {
            return SelectCompound.Operator.UNION_ALL;
        }
    ] {
        return SelectCompound.Operator.UNION;
    }
|   "INTERSECT" {
        return SelectCompound.Operator.INTERSECT;
    }
|   "EXCEPT" {
        return SelectCompound.Operator.EXCEPT;
    }
}

IndexedBy indexedBy() :
{
    IndexedBy indexed = new IndexedBy();
}
{
    [
	    (
	        "INDEXED" {
	            IndexName ind;
	            indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "BY"
	        ind = indexName() {
	            indexed.setIndex(ind);
	        }
	    |   "NOT" {
                indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "INDEXED"
	    ) {
            indexed.setEnd(token.endLine, token.endColumn);
            return indexed;
        }
    ] {
        return null;
    }
}

// Names
DatabaseName databaseName() :
{
}
{
    "wasd"
    {
        return null;
    }
}

TableName tableName() :
{
}
{
    "kad"
    {
        return null;
    }
}

ConstraintName name() :
{
}
{
    "rads" {
        return null;
    }
}

ColumnName columnName() :
{
    
}
{
    "vdsa" {
        return null;
    }
}

IndexName indexName() :
{
}
{
    "ew2" {
        return null;
    }
}

TableName foreignTable() :
{
}
{
    "t" {
        return null;
    }
}

CollationName collationName() :
{
}
{
    "DEFAULTs" {
        return null;
    }
}

ConstraintName constraintName() :
{
}
{
    "sd" {
        return null;
    }
}

ColumnAlias columnAlias() :
{
}
{
    "se" {
        return null;
    }
}

TableAlias tableAlias() :
{
}
{
    "esa" {
        return null;
    }
}

FunctionName functionName() :
{
}
{
    "asfd" {
        return null;
    }
}