options {
    LOOKAHEAD = 1;
    STATIC = false;
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.5";
    IGNORE_CASE = true ;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.name.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.drop.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;
import main.sqlipa.parser.ast.stmt.event.update.*;
import main.sqlipa.parser.ast.stmt.pragma.*;

final class ASTParser {
    public static void main(String args[]) {
        ASTParser parser = new ASTParser(System.in);
        try {
            parser.sqlStmt();
            System.out.println("Accept");
        } catch (ParseException e) {
            System.out.println("Reject");
        }
    }
} 
PARSER_END(ASTParser)

/* WHITE SPACE */

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* COMMENTS */

TOKEN_MGR_DECLS :
{
    private void CommonTokenAction(Token token) {

    }
}

// Prefixed tokens avoid name collisions.
//
// K_ - Keyword, O_ - Operator, S_ - Substitutes

TOKEN:
{
    <K_ABORT: "ABORT">
|   <K_ACTION: "ACTION">
|   <K_ADD: "ADD">
|   <K_AFTER: "AFTER">
|   <K_ALL: "ALL">
|   <K_ALTER: "ALTER">
|   <K_ANALYZE: "ANALYZE">
|   <K_AND: "AND">
|   <K_AS: "AS">
|   <K_ASC: "ASC">
|   <K_ATTACH: "ATTACH">
|   <K_AUTOINCREMENT: "AUTOINCREMENT">
|   <K_BEFORE: "BEFORE">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN: "BETWEEN">
|   <K_BY: "BY">
|   <K_CASCADE: "CASCADE">
|   <K_CASE: "CASE">
|   <K_CAST: "CAST">
|   <K_CHECK: "CHECK">
|   <K_COLLATE: "COLLATE">
|   <K_COLUMN: "COLUMN">
|   <K_COMMIT: "COMMIT">
|   <K_CONFLICT: "CONFLICT">
|   <K_CONSTRAINT: "CONSTRAINT">
|   <K_CREATE: "CREATE">
|   <K_CROSS: "CROSS">
|   <K_CURRENT_DATE: "CURRENT_DATE">
|   <K_CURRENT_TIME: "CURRENT_TIME">
|   <K_CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <K_DATABASE: "DATABASE">
|   <K_DEFAULT: "DEFAULT">
|   <K_DEFERRABLE: "DEFERRABLE">
|   <K_DEFERRED: "DEFERRED">
|   <K_DELETE: "DELETE">
|   <K_DESC: "DESC">
|   <K_DETACH: "DETACH">
|   <K_DISTINCT: "DISTINCT">
|   <K_DROP: "DROP">
|   <K_EACH: "EACH">
|   <K_ELSE: "ELSE">
|   <K_END: "END">
|   <K_ESCAPE: "ESCAPE">
|   <K_EXCEPT: "EXCEPT">
|   <K_EXCLUSIVE: "EXCLUSIVE">
|   <K_EXISTS: "EXISTS">
|   <K_EXPLAIN: "EXPLAIN">
|   <K_FAIL: "FAIL">
|   <K_FOR: "FOR">
|   <K_FOREIGN: "FOREIGN">
|   <K_FROM: "FROM">
|   <K_FULL: "FULL">
|   <K_GLOB: "GLOB">
|   <K_GROUP: "GROUP">
|   <K_HAVING: "HAVING">
|   <K_IF: "IF">
|   <K_IGNORE: "IGNORE">
|   <K_IMMEDIATE: "IMMEDIATE">
|   <K_IN: "IN">
|   <K_INDEX: "INDEX">
|   <K_INDEXED: "INDEXED">
|   <K_INITIALLY: "INITIALLY">
|   <K_INNER: "INNER">
|   <K_INSERT: "INSERT">
|   <K_INSTEAD: "INSTEAD">
|   <K_INTERSECT: "INTERSECT">
|   <K_INTO: "INTO">
|   <K_IS: "IS">
|   <K_ISNULL: "ISNULL">
|   <K_JOIN: "JOIN">
|   <K_KEY: "KEY">
|   <K_LEFT: "LEFT">
|   <K_LIKE: "LIKE">
|   <K_LIMIT: "LIMIT">
|   <K_MATCH: "MATCH">
|   <K_NATURAL: "NATURAL">
|   <K_NO: "NO">
|   <K_NOT: "NOT">
|   <K_NOTNULL: "NOTNULL">
|   <K_NULL: "NULL">
|   <K_OF: "OF">
|   <K_OFFSET: "OFFSET">
|   <K_ON: "ON">
|   <K_OR: "OR">
|   <K_ORDER: "ORDER">
|   <K_OUTER: "OUTER">
|   <K_PLAN: "PLAN">
|   <K_PRAGMA: "PRAGMA">
|   <K_PRIMARY: "PRIMARY">
|   <K_QUERY: "QUERY">
|   <K_RAISE: "RAISE">
|   <K_REFERENCES: "REFERENCES">
|   <K_REGEXP: "REGEXP">
|   <K_REINDEX: "REINDEX">
|   <K_RELEASE: "RELEASE">
|   <K_RENAME: "RENAME">
|   <K_REPLACE: "REPLACE">
|   <K_RESTRICT: "RESTRICT">
|   <K_RIGHT: "RIGHT">
|   <K_ROLLBACK: "ROLLBACK">
|   <K_ROW: "ROW">
|   <K_SAVEPOINT: "SAVEPOINT">
|   <K_SELECT: "SELECT">
|   <K_SET: "SET">
|   <K_TABLE: "TABLE">
|   <K_TEMP: "TEMP">
|   <K_TEMPORARY: "TEMPORARY">
|   <K_THEN: "THEN">
|   <K_TO: "TO">
|   <K_TRANSACTION: "TRANSACTION">
|   <K_TRIGGER: "TRIGGER">
|   <K_UNION: "UNION">
|   <K_UNIQUE: "UNIQUE">
|   <K_UPDATE: "UPDATE">
|   <K_USING: "USING">
|   <K_VACUUM: "VACUUM">
|   <K_VALUES: "VALUES">
|   <K_VIEW: "VIEW">
|   <K_VIRTUAL: "VIRTUAL">
|   <K_WHEN: "WHEN">
|   <K_WHERE: "WHERE">
}

void sqlStmtList() :{}
{    (sqlStmt())*
}

SqlStatement sqlStmt() :
{
    Block block = new ExpansibleBlock();
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            block.setBegin(token.beginLine, token.beginColumn);
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    // Each statement function receives a Block to get the begin values in case 
    // the statement doesn't start by EXPLAIN. To get the right values is used 
    // an ExpansibleBlock.
    (
        stmt = alterTableStmt(block)
    |   stmt = analyzeStmt(block)
    |   stmt = attachStmt(block)
	|   stmt = beginStmt(block)
	|   stmt = commitStmt(block)
	|   stmt = createIndexStmt(block)
	|   stmt = createTableStmt(block)
	|   stmt = createTriggerStmt(block)
	|   stmt = createViewStmt(block)
	|   stmt = createVirtualTableStmt(block)	|   stmt = deleteStmt(block)
	|   stmt = deleteStmtLimited(block)
	|   stmt = detachStmt(block)
	|   stmt = dropIndexStmt(block)
	|   stmt = dropTableStmt(block)
	|   stmt = dropTriggerStmt(block)
	|   stmt = dropViewStmt(block)
	|   stmt = insertStmt(block)
	|   stmt = pragmaStmt(block)
	|   stmt = reindexStmt(block)
	|   stmt = releaseStmt(block)
	|   stmt = rollbackStmt(block)
	|   stmt = savepointStmt(block)
	|   stmt = selectStmt(block)
	|   stmt = updateStmt(block)
	|   stmt = updateStmtLimited(block)
	|   stmt = vacuumStmt(block)
	) {
	   block.setEnd(token.endLine, token.endColumn);
	   stmt.setBlock(block);
	   stmt.setExplain(explain);
	   return stmt;
    }
}

SqlStatement alterTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ALTER"
    {
        return stmt;
    }}

SqlStatement analyzeStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ANALYZE"
    {
        return stmt;
    }
}

SqlStatement attachStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ATTACH"
    {
        return stmt;
    }
}

SqlStatement beginStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "BEGIN"
    {
        return stmt;
    }
}

SqlStatement commitStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "COMMIT"
    {
        return stmt;
    }
}

SqlStatement rollbackStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "ROLLBACK"
    {
        return stmt;
    }
}

SqlStatement savepointStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "SAVEPOINT"
    {
        return stmt;
    }
}

SqlStatement releaseStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "RELEASE"
    {
        return stmt;
    }
}

SqlStatement createIndexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE INDEX"
    {
        return stmt;
    }
}

void indexedColumn() :
{
}
{
    "b"}

CreateTableStmt createTableStmt(Block block) :
{
    CreateTableStmt stmt;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    DatabaseName db = null;
    TableName tab;
    SelectStmt select = null;}
{
    "CREATE" {
        block.setBegin(token.beginLine, token.beginColumn); 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF NOT EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        db = databaseName() "."
    ]
    tab = tableName()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(tab);
        stmt.setDatabase(db);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
    TableConstraint constraint;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(column);
    }
    (
        LOOKAHEAD(2)
        "," 
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," 
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmtWithSelect createTableStmtWithSelect() :
{
    SelectStmt select;
}
{
    "AS"
    select = selectStmt(new ExpansibleBlock()) {
        return new CreateTableStmtWithSelect(select);
    }
}

ColumnDef columnDef() :
{
    ColumnDef column = null;}
{
    columnName()
    [typeName()]
    (columnConstraint())*
    {
        return column;
    }}

void typeName() :
{}
{
    (name())+
    ["(" signedNumber() ["," signedNumber()] ")"]}

void columnConstraint() :
{}
{
    ["CONSTRAINT" name()]
    (
        "PRIMARY" "KEY" [("ASC" | "DESC")] conflictClause() ["AUTOINCREMENT"]
    |   "NOT" "NULL" conflictClause()
    |   "UNIQUE" conflictClause()
    |   "CHECK" "(" expr() ")"
    |   "DEFAULT" (signedNumber() | literalValue() | "(" expr() ")")    |   "COLLATE" collationName()
    |   foreignKeyClause()
    )
}

void signedNumber() :
{}
{
    [("+" | "-")]
    numericLiteral()}

TableConstraint tableConstraint() :
{
    TableConstraint constraint = null;}
{
    ["CONSTRAINT" name()]
    (
        ("PRIMARY" "KEY" | "UNIQUE") "(" indexedColumn() ("," indexedColumn())* ")" conflictClause()
    |   "CHECK" "(" expr() ")"
    |   "FOREIGN" "KEY" "(" columnName() ("," columnName())* ")" foreignKeyClause()
    )
    {
        return constraint;
    }}

void foreignKeyClause() :
{}
{
    "REFERENCES"
    foreignTable()
    ["(" columnName() ("," columnName())* ")"]
    (
        "ON"
        (   
            "DELETE"
        |   "UPDATE")
        (
            "SET" 
            (
              "NULL"
            | "CASCADE"
            )
        |   "CASCADE"
        |   "RESTRICT"
        |   "NO" "ACTION"
        )
    |   "MATCH" name()
    )*
    [LOOKAHEAD(2) ["NOT"] "DEFERRABLE" ["INITIALLY" ("DEFERRED" | "IMMEDIATE")]]}

void conflictClause() :
{}
{
    [   
        "ON" 
        "CONFLICT"
        (
            "ROLLBACK"
        |   "ABORT"
        |   "FAIL"
        |   "IGNORE"
        |   "REPLACE"
        )
    ]}

SqlStatement createTriggerStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE TRIGGER"
    {
        return stmt;
    }
}

SqlStatement createViewStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIEW"
    {
        return stmt;
    }
}

SqlStatement createVirtualTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIRTUAL"
    {
        return stmt;
    }
}

SqlStatement deleteStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DELETE"
    {
        return stmt;
    }
}

SqlStatement deleteStmtLimited(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DELETE limited"
    {
        return stmt;
    }
}

SqlStatement detachStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DETACH"
    {
        return stmt;
    }
}

SqlStatement dropIndexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP INDEX"
    {
        return stmt;
    }
}

SqlStatement dropTableStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP TABLE"
    {
        return stmt;
    }
}

SqlStatement dropTriggerStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP TRIGGER"
    {
        return stmt;
    }
}

SqlStatement dropViewStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "DROP VIEW"
    {
        return stmt;
    }
}

void expr() :
{}
{
    "c"}

void raiseFunction() :
{}
{
    "d"}

void literalValue() :
{}
{
    "a"}

void numericLiteral() :
{}
{
    "e"}

SqlStatement insertStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "INSERT"
    {
        return stmt;
    }
}

SqlStatement pragmaStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "PRAGMA"
    {
        return stmt;
    }
}

void pragmaValue() :
{}
{
    "q"}

SqlStatement reindexStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "REINDEX"
    {
        return stmt;
    }
}

SelectStmt selectStmt(Block block) :
{
    SelectStmt stmt = null;
}
{
    "SELECT"
    {
        return stmt;
    }
}


void selectCore() :
{}
{
    "as"}


void resultColumn() :
{}
{
    "d"}

void joinSource() :
{}
{
    "f"}

void singleSource() :
{}
{
    "g"}

void joinOp() :
{}
{
    "h"}

void joinConstraint() :
{}
{
    "j"}

void orderingTerm() :
{}
{
    "k"}

void compoundOperator() :
{}
{
    "l"}

SqlStatement updateStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "UPDATE"
    {
        return stmt;
    }
}

SqlStatement updateStmtLimited(Block block) :
{
    SqlStatement stmt = null;
}
{
    "UPDATE limi"
    {
        return stmt;
    }
}

void qualifiedTableName() :
{}
{
    "m"}

SqlStatement vacuumStmt(Block block) :
{
    SqlStatement stmt = null;
}
{
    "VACUUM"
    {
        return stmt;
    }
}

// Functions not mentioned in the specification.
DatabaseName databaseName() :
{
}
{
    "w"
    {
        return null;
    }
}

TableName tableName() :
{
}
{
    "e"
    {
        return null;
    }
}

void name() :
{
}
{
    "r"
}

void columnName() :
{
}
{
    "v"
}

void foreignTable() :
{
}
{
    "t"
}

void collationName() :
{
}
{
    "y"
}