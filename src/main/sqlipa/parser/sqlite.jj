options {
    LOOKAHEAD = 1;
    STATIC = false;
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.5";
    IGNORE_CASE = true ;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.name.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.drop.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;
import main.sqlipa.parser.ast.stmt.event.update.*;
import main.sqlipa.parser.ast.stmt.pragma.*;

final class ASTParser {

    public static void main(String args[]) {
        ASTParser parser = new ASTParser(System.in);
        try {
            parser.sqlStmt();
            System.out.println("Accept");
        } catch (ParseException e) {
            System.out.println("Reject");
        }
    }

} 
PARSER_END(ASTParser)

/* WHITE SPACE */

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* COMMENTS */

TOKEN_MGR_DECLS :
{
    private void CommonTokenAction(Token token) {

    }
}

// Prefixed tokens avoid name collisions.
//
// K_ - Keyword, O_ - Operator, S_ - Substitutes

TOKEN:
{
    <K_ABORT: "ABORT">
|   <K_ACTION: "ACTION">
|   <K_ADD: "ADD">
|   <K_AFTER: "AFTER">
|   <K_ALL: "ALL">
|   <K_ALTER: "ALTER">
|   <K_ANALYZE: "ANALYZE">
|   <K_AND: "AND">
|   <K_AS: "AS">
|   <K_ASC: "ASC">
|   <K_ATTACH: "ATTACH">
|   <K_AUTOINCREMENT: "AUTOINCREMENT">
|   <K_BEFORE: "BEFORE">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN: "BETWEEN">
|   <K_BY: "BY">
|   <K_CASCADE: "CASCADE">
|   <K_CASE: "CASE">
|   <K_CAST: "CAST">
|   <K_CHECK: "CHECK">
|   <K_COLLATE: "COLLATE">
|   <K_COLUMN: "COLUMN">
|   <K_COMMIT: "COMMIT">
|   <K_CONFLICT: "CONFLICT">
|   <K_CONSTRAINT: "CONSTRAINT">
|   <K_CREATE: "CREATE">
|   <K_CROSS: "CROSS">
|   <K_CURRENT_DATE: "CURRENT_DATE">
|   <K_CURRENT_TIME: "CURRENT_TIME">
|   <K_CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <K_DATABASE: "DATABASE">
|   <K_DEFAULT: "DEFAULT">
|   <K_DEFERRABLE: "DEFERRABLE">
|   <K_DEFERRED: "DEFERRED">
|   <K_DELETE: "DELETE">
|   <K_DESC: "DESC">
|   <K_DETACH: "DETACH">
|   <K_DISTINCT: "DISTINCT">
|   <K_DROP: "DROP">
|   <K_EACH: "EACH">
|   <K_ELSE: "ELSE">
|   <K_END: "END">
|   <K_ESCAPE: "ESCAPE">
|   <K_EXCEPT: "EXCEPT">
|   <K_EXCLUSIVE: "EXCLUSIVE">
|   <K_EXISTS: "EXISTS">
|   <K_EXPLAIN: "EXPLAIN">
|   <K_FAIL: "FAIL">
|   <K_FOR: "FOR">
|   <K_FOREIGN: "FOREIGN">
|   <K_FROM: "FROM">
|   <K_FULL: "FULL">
|   <K_GLOB: "GLOB">
|   <K_GROUP: "GROUP">
|   <K_HAVING: "HAVING">
|   <K_IF: "IF">
|   <K_IGNORE: "IGNORE">
|   <K_IMMEDIATE: "IMMEDIATE">
|   <K_IN: "IN">
|   <K_INDEX: "INDEX">
|   <K_INDEXED: "INDEXED">
|   <K_INITIALLY: "INITIALLY">
|   <K_INNER: "INNER">
|   <K_INSERT: "INSERT">
|   <K_INSTEAD: "INSTEAD">
|   <K_INTERSECT: "INTERSECT">
|   <K_INTO: "INTO">
|   <K_IS: "IS">
|   <K_ISNULL: "ISNULL">
|   <K_JOIN: "JOIN">
|   <K_KEY: "KEY">
|   <K_LEFT: "LEFT">
|   <K_LIKE: "LIKE">
|   <K_LIMIT: "LIMIT">
|   <K_MATCH: "MATCH">
|   <K_NATURAL: "NATURAL">
|   <K_NO: "NO">
|   <K_NOT: "NOT">
|   <K_NOTNULL: "NOTNULL">
|   <K_NULL: "NULL">
|   <K_OF: "OF">
|   <K_OFFSET: "OFFSET">
|   <K_ON: "ON">
|   <K_OR: "OR">
|   <K_ORDER: "ORDER">
|   <K_OUTER: "OUTER">
|   <K_PLAN: "PLAN">
|   <K_PRAGMA: "PRAGMA">
|   <K_PRIMARY: "PRIMARY">
|   <K_QUERY: "QUERY">
|   <K_RAISE: "RAISE">
|   <K_REFERENCES: "REFERENCES">
|   <K_REGEXP: "REGEXP">
|   <K_REINDEX: "REINDEX">
|   <K_RELEASE: "RELEASE">
|   <K_RENAME: "RENAME">
|   <K_REPLACE: "REPLACE">
|   <K_RESTRICT: "RESTRICT">
|   <K_RIGHT: "RIGHT">
|   <K_ROLLBACK: "ROLLBACK">
|   <K_ROW: "ROW">
|   <K_SAVEPOINT: "SAVEPOINT">
|   <K_SELECT: "SELECT">
|   <K_SET: "SET">
|   <K_TABLE: "TABLE">
|   <K_TEMP: "TEMP">
|   <K_TEMPORARY: "TEMPORARY">
|   <K_THEN: "THEN">
|   <K_TO: "TO">
|   <K_TRANSACTION: "TRANSACTION">
|   <K_TRIGGER: "TRIGGER">
|   <K_UNION: "UNION">
|   <K_UNIQUE: "UNIQUE">
|   <K_UPDATE: "UPDATE">
|   <K_USING: "USING">
|   <K_VACUUM: "VACUUM">
|   <K_VALUES: "VALUES">
|   <K_VIEW: "VIEW">
|   <K_VIRTUAL: "VIRTUAL">
|   <K_WHEN: "WHEN">
|   <K_WHERE: "WHERE">
}

void sqlStmtList() :{}
{
    (sqlStmt())*
}

SqlStatement sqlStmt() :
{
    int line = 0;
    int column = 0;
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            line = token.beginLine;
            column = token.beginColumn;
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    (
        stmt = alterTableStmt()
    |   stmt = analyzeStmt()
    |   stmt = attachStmt()
	|   stmt = beginStmt()
	|   stmt = commitStmt()
	|   stmt = createIndexStmt()
	|   stmt = createTableStmt()
	|   stmt = createTriggerStmt()
	|   stmt = createViewStmt()
	|   stmt = createVirtualTableStmt()	|   stmt = deleteStmt()
	|   stmt = deleteStmtLimited()
	|   stmt = detachStmt()
	|   stmt = dropIndexStmt()
	|   stmt = dropTableStmt()
	|   stmt = dropTriggerStmt()
	|   stmt = dropViewStmt()
	|   stmt = insertStmt()
	|   stmt = pragmaStmt()
	|   stmt = reindexStmt()
	|   stmt = releaseStmt()
	|   stmt = rollbackStmt()
	|   stmt = savepointStmt()
	|   stmt = selectStmt()
	|   stmt = updateStmt()
	|   stmt = updateStmtLimited()
	|   stmt = vacuumStmt()
	) {
        if (explain != null) {
            // If statement starts by EXPLAIN.
            stmt.setBegin(line, column);
            stmt.setExplain(explain);
        }
        return stmt;
    }
}

SqlStatement alterTableStmt() :
{
    SqlStatement stmt = null;
}
{
    "ALTER"
    {
        return stmt;
    }}

SqlStatement analyzeStmt() :
{
    SqlStatement stmt = null;
}
{
    "ANALYZE"
    {
        return stmt;
    }
}

SqlStatement attachStmt() :
{
    SqlStatement stmt = null;
}
{
    "ATTACH"
    {
        return stmt;
    }
}

SqlStatement beginStmt() :
{
    SqlStatement stmt = null;
}
{
    "BEGIN"
    {
        return stmt;
    }
}

SqlStatement commitStmt() :
{
    SqlStatement stmt = null;
}
{
    "COMMIT"
    {
        return stmt;
    }
}

SqlStatement rollbackStmt() :
{
    SqlStatement stmt = null;
}
{
    "ROLLBACK"
    {
        return stmt;
    }
}

SqlStatement savepointStmt() :
{
    SqlStatement stmt = null;
}
{
    "SAVEPOINT"
    {
        return stmt;
    }
}

SqlStatement releaseStmt() :
{
    SqlStatement stmt = null;
}
{
    "RELEASE"
    {
        return stmt;
    }
}

SqlStatement createIndexStmt() :
{
    SqlStatement stmt = null;
}
{
    "CREATE INDEX"
    {
        return stmt;
    }
}

IndexedColumn indexedColumn() :
{
    IndexedColumn indColumn = new IndexedColumn();
    ColumnName column;
}
{
    column = columnName() {
        indColumn.setColumn(column);
        indColumn.setBegin(column.beginLine, column.beginColumn);
    }
    [
        "COLLATE" {
            CollationName collation;
        }
        collation = collationName() {
            indColumn.setCollation(collation);
        }
    ]
    [
        (
            "ASC" {
                indColumn.setOrder(IndexedColumn.Order.ASC);
            }
        |   "DESC" {
                indColumn.setOrder(IndexedColumn.Order.DESC);
            }
        )
    ] {
        indColumn.setEnd(token.endLine, token.endColumn);
        return indColumn;
    }}

CreateTableStmt createTableStmt() :
{
    CreateTableStmt stmt;
    int line;
    int column;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    DatabaseName db = null;
    TableName tab;
}
{
    "CREATE" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        db = databaseName() "."
    ]
    tab = tableName()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.setTemporary(hasTemp);
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(tab);
        stmt.setDatabase(db);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(columnDef());
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHAED(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        "," 
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," {
            TableConstraint constraint;
        }
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmtWithSelect createTableStmtWithSelect() :
{
    SelectStmt select;
}
{
    "AS"
    select = selectStmt() {
        return new CreateTableStmtWithSelect(select);
    }
}

ColumnDef columnDef() :
{
    ColumnDef columnDef = new ColumnDef();
    ColumnName column;
    TypeName type;
    ColumnConstraint constraint;}
{
    column = columnName() {
        columnDef.setColumn(column);
        columnDef.setBegin(column.beginLine, column.beginColumn);
    }
    [
        type = typeName() {
            columnDef.setType(type);
        }
    ]
    (
        constraint = columnConstraint() {
            columnDef.addConstraint(constraint);
        }
    )* {
        columnDef.setEnd(token.endLine, token.endColumn);
        return columnDef;
    }}

TypeName typeName() :
{
    TypeName type = new TypeName();
    String name = new String();
    
    type.setName(name);}
{
    name() {
        // TODO: name must return.
        type.setBegin(token.beginLine, token.beginColumn);
        name += token.image;
    }
    (
        name() {
            name += " " + token.image;
        }
    )*
    [
        "(" {
            SignedNumber xDim;
        }
        xDim = signedNumber() {
            type.setDimensionInX(xDim);
        }
        [
            "," {
                SignedNumber yDim;
            }
            yDim = signedNumber() {
                type.setDimensionInY(yDim);
            }
        ]
        ")"
    ] {
        type.setEnd(token.endLine, token.endColumn);
        return type;
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    int line = 0;
    int column = 0;
    ConstraintName name = null;}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyColumnConstraint()
    |   constraint = notNullColumnConstraint()
    |   constraint = uniqueColumnConstraint()
    |   constraint = checkColumnConstraint()
    |   constraint = defaultColumnConstraint()    |   constraint = collateColumnConstraint()
    |   constraint = foreignKeyColumnConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint() :
{
    PrimaryKeyColumnConstraint constraint = new PrimaryKeyColumnConstraint();
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        (
            "ASC" {
                constraint.setOrder(PrimaryKeyColumnConstraint.Order.ASC);
            }
        |   "DESC" {
                constraint.setOrder(PrimaryKeyColumnConstraint.Order.DESC);
            }
        )
    ]
    clause = conflictClause() {
        constraint.setClause(clause);
    }
    [
        "AUTOINCREMENT" {
            constraint.setAutoincrement(true);
        }
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

NotNullColumnConstraint notNullColumnConstraint() :
{
    NotNullColumnConstraint constraint = new NotNullColumnConstraint();
    ConflictClause clause;
}
{
    "NOT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueColumnConstraint uniqueColumnConstraint() :
{
    UniqueColumnConstraint constraint = new UniqueColumnConstraint();
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckColumnConstraint checkColumnConstraint() :
{
    CheckColumnConstraint constraint = new CheckColumnConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    expr = expr()
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

DefaultColumnConstraint defaultColumnConstraint() :
{
    DefaultColumnConstraint constraint;
    int line;
    int column;
}
{
    "DEFAULT" {
        line = token.beginLine;
        column = token.beginColumn;
    }
    (
        constraint = numberColumnConstraint()
    |   constraint = literalColumnConstraint()
    |   constraint = expressionColumnConstraint()
    ) {
        constraint.setBegin(line, column);
        return constraint;
    }
}

NumberColumnConstraint numberColumnConstraint():
{
    NumberColumnConstraint constraint = new NumberColumnConstraint();
    SignedNumber number;
}
{
    number = signedNumber() {
        constraint.setBeginEnd(number);
        constraint.setNumber(number);
        return constraint;
    }
}

LiteralColumnConstraint literalColumnConstraint() :
{
    LiteralColumnConstraint constraint = new LiteralColumnConstraint();
    Literal literal;
}
{
    literal = literalValue() {
        constraint.setBeginEnd(literal);
        constraint.setLiteral(literal);
        return constraint;
    }
}

ExpressionColumnConstraint expressionColumnConstraint() :
{
    ExpressionColumnConstraint constraint = new ExpressionColumnConstraint();
    Expression expr;
}
{
    "(" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr()
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        constraint.setExpression(expr);
        return constraint;
    }
}

CollateColumnConstraint collateColumnConstraint() :
{
    CollateColumnConstraint constraint = new CollateColumnConstraint();
    CollationName collation;
}
{
    "COLLATE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    collation = collationName() {
        constraint.setCollation(collation);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint() :
{
    ForeignKeyColumnConstraint constraint = new ForeignKeyColumnConstraint();
    ForeignKeyClause clause;
}
{
    clause = foreignKeyClause() {
        constraint.setBeginEnd(clause);
        constraint.setClause(clause);
        return constraint;
    }
}

SignedNumber signedNumber() :
{
    SignedNumber number = new SignedNumber();
    NumericLiteral literal;}
{
    [
        (
            "+" {
                number.setSign(SignedNumber.Sign.PLUS);
            }
        |   "-" {
                number.setSign(SignedNumber.Sign.MINUS);
            }
        ) {
            number.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        if (number.getSign() == null) {
            number.setBeginEnd(literal);
        } else {
            number.setEnd(token.endLine, token.endColumn);
        }
        number.setLiteral(literal);
        return number;
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    int line = 0;
    int column = 0;
    ConstraintName name = null;
}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyTableConstraint()
    |   constraint = checkTableConstraint()
    |   constraint = foreignKeyTableConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint() :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint() :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint() :
{
    CheckTableConstraint constraint = new CheckTableConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() 
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint() :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    ColumnName column;
    ForeignKeyClause clause;
}
{
    "FOREIGN" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = columnName() {
        constraint.addColumn(column);
    }
    (
        "," 
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = foreignKeyClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{
    ForeignKeyClause clause = new ForeignKeyClause();
    Block block = new Block();
    TableName tab;
    ForeignKeySetting sett;}
{
    "REFERENCES" {
        clause.setBegin(token.beginLine, token.beginColumn);
    }
    tab = foreignTable() {
        clause.setTable(tab);
    }
    [
        "(" {
            ColumnName column;
        }
        column = columnName() {
            clause.addColumn(column);
        }
        (
            ","
            column = columnName() {
                clause.addColumn(column);
            }
        )*
        ")"
    ]
    (
        sett = onForeignKeySett() {
            clause.addSetting(sett);
        }
    |   sett = matchForeignKeySett() {
            clause.addSetting(sett);
        }
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
        sett = deferrableForeignKeySett() {
            clause.addSetting(sett);
        }
    ] {
        clause.setEnd(token.endLine, token.endColumn);
        return clause;
    }}

OnForeignKeySett onForeignKeySett() :
{
    OnForeignKeySett sett = new OnForeignKeySett();
}
{
    "ON" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    (
        "DELETE" {
            sett.setEvent(OnForeignKeySett.Event.DELETE);
        }
    |   "UPDATE" {
            sett.setEvent(OnForeignKeySett.Event.UPDATE);
        }
    )
    (
        "SET" // SET merged to remove ambiguity.
        (
            "NULL" {
                sett.setAction(OnForeignKeySett.Action.SET_NULL);
            }
        |   "DEFAULT" {
                sett.setAction(OnForeignKeySett.Action.SET_DEFAULT);
            }
        )
    |   "CASCADE" {
            sett.setAction(OnForeignKeySett.Action.CASCADE);
        }
    |   "RESTRICT" {
            sett.setAction(OnForeignKeySett.Action.RESTRICT);
        }
    |   "NO" "ACTION" {
            sett.setAction(OnForeignKeySett.Action.NO_ACTION);
        }
    ) {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

MatchForeignKeySett matchForeignKeySett() :
{
    MatchForeignKeySett sett = new MatchForeignKeySett();
    Name name;
}
{
    "MATCH" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    name = name() {
        sett.setName(name);
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

DeferrableForeignKeySett deferrableForeignKeySett() :
{
    DeferrableForeignKeySett sett = new DeferrableForeignKeySett();
}
{
    (
        "NOT" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.NOT_DEFERRABLE);
        }
        "DEFERRABLE"
    |   "DEFERRABLE" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.DEFERRABLE);
        }
    )
    [
        "INITIALLY"
        (
            "DEFERRED" {
                sett.setMode(DeferrableForeignKeySett.Mode.DEFERRED);
            }
        |   "IMMEDIATE" {
                sett.setMode(DeferrableForeignKeySett.Mode.IMMEDIATE);
            }
        )
    ] {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

ConflictClause conflictClause() :
{
}
{
    [   
        "ON" {
            ConflictClause clause = new ConflictClause();
            clause.setBegin(token.beginLine, token.beginColumn);
        }
        "CONFLICT"
        (
            "ROLLBACK" {
                clause.setAction(ConflictClause.Action.ROLLBACK);
            }
        |   "ABORT" {
                clause.setAction(ConflictClause.Action.ABORT);
            }
        |   "FAIL" {
                clause.setAction(ConflictClause.Action.FAIL);
            }
        |   "IGNORE" {
                clause.setAction(ConflictClause.Action.IGNORE);
            }
        |   "REPLACE" {
                clause.setAction(ConflictClause.Action.REPLACE);
            }
        ) {
            clause.setEnd(token.endLine, token.endColumn);
            return clause;
        }
    ] {
        return null;
    }}

SqlStatement createTriggerStmt() :
{
    SqlStatement stmt = null;
}
{
    "CREATE TRIGGER"
    {
        return stmt;
    }
}

SqlStatement createViewStmt() :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIEW"
    {
        return stmt;
    }
}

SqlStatement createVirtualTableStmt() :
{
    SqlStatement stmt = null;
}
{
    "CREATE VIRTUAL"
    {
        return stmt;
    }
}

SqlStatement deleteStmt() :
{
    SqlStatement stmt = null;
}
{
    "DELETE"
    {
        return stmt;
    }
}

SqlStatement deleteStmtLimited() :
{
    SqlStatement stmt = null;
}
{
    "DELETE limited"
    {
        return stmt;
    }
}

SqlStatement detachStmt() :
{
    SqlStatement stmt = null;
}
{
    "DETACH"
    {
        return stmt;
    }
}

SqlStatement dropIndexStmt() :
{
    SqlStatement stmt = null;
}
{
    "DROP INDEX"
    {
        return stmt;
    }
}

SqlStatement dropTableStmt() :
{
    SqlStatement stmt = null;
}
{
    "DROP TABLE"
    {
        return stmt;
    }
}

SqlStatement dropTriggerStmt() :
{
    SqlStatement stmt = null;
}
{
    "DROP TRIGGER"
    {
        return stmt;
    }
}

SqlStatement dropViewStmt() :
{
    SqlStatement stmt = null;
}
{
    "DROP VIEW"
    {
        return stmt;
    }
}

Expression expr() :
{}
{
    "c" {
        return null;
    }}

void raiseFunction() :
{}
{
    "d"}

Literal literalValue() :
{}
{
    "a" {
        return null;
    }}

NumericLiteral numericLiteral() :
{}
{
    "e" {
        return null;
    }}

SqlStatement insertStmt() :
{
    SqlStatement stmt = null;
}
{
    "INSERT"
    {
        return stmt;
    }
}

SqlStatement pragmaStmt() :
{
    SqlStatement stmt = null;
}
{
    "PRAGMA"
    {
        return stmt;
    }
}

void pragmaValue() :
{}
{
    "q"}

SqlStatement reindexStmt() :
{
    SqlStatement stmt = null;
}
{
    "REINDEX"
    {
        return stmt;
    }
}

SelectStmt selectStmt() :
{
    SelectStmt stmt = new SelectStmt();
    SelectUnit unit;
    SelectCompound.Operator op;
    SelectUnit core;
}
{
    unit = selectCore() {
        stmt.setBegin(unit.beginLine, unit.beginColumn);
    }
    (
        op = compoundOperator()
        core = selectCore() {
            unit = new SelectCompound(new Block(unit.beginLine, 
                unit.beginColumn, token.endLine, token.endColumn), unit, core,
                op);
        }
    )* {
        stmt.setUnit(unit);
    }
    [
        "ORDER" "BY" {
            OrderingTerm term;
        }
        term = orderingTerm() {
            stmt.addTerm(term);
        }
        (
            ","
            term = orderingTerm() {
                stmt.addTerm(term);
            }
        )*
    ]
    [
        "LIMIT" {
            Expression expr;
        }
        expr = expr() {
            stmt.setLimit(expr);
        }
        [
            ( "OFFSET" | "," )
            expr = expr() {
                stmt.setOffset(expr);
            }
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}


SelectCore selectCore() :
{
    SelectCore core = new SelectCore();
    ResultColumn column;}
{
    "SELECT" {
        core.setBegin(token.beginLine, token.beginColumn);
    }
    [
        (
            "DISTINCT" {
                core.setDistinct(true);
            }
        |   "ALL"
        )
    ]
    column = resultColumn() {
        core.addColumn(column);
    }
    (
        ","
        resultColumn() {
	        core.addColumn(column);
	    }
    )*
    [
        "FROM" {
            JoinSrc src;
        }
        src = joinSource() {
            core.setFrom(src);
        }
    ]
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            core.setWhere(expr);
        }
    ]
    [
        "GROUP" "BY" {
            Expression expr;
        }
        expr = expr() {
            core.addGroupByExpression(expr);
        }
        (
            ","
            expr = expr() {
                core.addGroupByExpression(expr);
            }
        )*
        [
            "HAVING"
            expr = expr() {
                core.setHaving(expr);
            }
        ]
    ] {
        core.setEnd(token.endLine, token.endColumn);
        return core;
    }
}

ResultColumn resultColumn() :
{
    ResultColumn column;}
{
    (
        column = universalColumn()
    |   column = expressionColumn()
    ) {
        return column;
    }}

UniversalColumn universalColumn() :
{
    UniversalColumn column = new UniversalColumn();
    TableName tab;
}
{
    (
        "*" {
            column.setBeginEnd(token.beginLine, token.beginColumn,
                token.endLine, token.endColumn);
        }
    |   tab = tableName() {
            column.setTable(tab);
        }
        "." 
        "*" {
            column.setBeginEnd(tab.beginLine, tab.beginColumn, token.endLine,
                token.endColumn);
        }
    ) {
        return column;
    }
}

ExpressionColumn expressionColumn() :
{
    ExpressionColumn column;
    Expression expr;
    ColumnAlias alias;
}
{
    expr = expr()
    [
        [ "AS" ]
        alias = columnAlias() {
            // TODO: line numbers.
            column = new AliasedColumn();
            column.setExpression(expr);
            column.setAlias(alias);
            return column;
        }
    ] {
        column = new ExpressionColumn();
        column.setExpression(expr);
        return column;
    }
}

JoinSrc joinSource() :
{
    JoinSrc src;
    JoinCompound.Operator op;
    JoinSrc right;
    JoinConstraint constraint;}
{
    src = singleSource()
    (
        op = joinOp()
        right = singleSource()
        constraint = joinConstraint() {
            src = new JoinCompound(new Block(src.beginLine, src.beginColumn,
                token.endLine, token.endColumn), src, right, op, constraint);
        }
    )* {
        return src;
    }}

JoinSrc singleSource() :
{
    JoinSrc src;
    int line = 0;
    int column = 0;}
{
    (
        src = tableSource()
    |   src = selectSource()
    |   "(" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        src = joinSource()
        ")" {
            src.setBeginEnd(line, column, token.endLine, token.endColumn);
        }
    ) {
        return src;
    }}

TableSrc tableSource() :
{
    TableSrc src = new TableSrc();
    DatabaseName db = null;
    TableName tab;
    IndexedBy indexed;
}
{
    [
        db = databaseName() {
            src.setDatabase(db);
            src.setBegin(db.beginLine, db.beginColumn);
        }
        "."
    ]
    tab = tableName() {
        src.setTable(tab);
        if (db == null) {
            src.setBegin(tab.beginLine, tab.beginColumn);
        }
    }
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ]
    indexed = indexedBy() {
        src.setIndexed(indexed);
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

SelectSrc selectSource() :
{
    SelectSrc src = new SelectSrc();
    SelectStmt stmt;
}
{
    "(" {
        src.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt() {
        src.setStatement(stmt);
    }
    ")"
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ] {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

void joinOp() :
{}
{
    "h"}

void joinConstraint() :
{}
{
    "j"}

OrderingTerm orderingTerm() :
{}
{
    "k" {
        return null;
    }}

SelectCompound.Operator compoundOperator() :
{
}
{
    (
        "UNION" [ "ALL" ]
    |   "INTERSECT"
    |   "EXCEPT"
    ) {
        return null;
    }
}

SqlStatement updateStmt() :
{
    SqlStatement stmt = null;
}
{
    "UPDATE"
    {
        return stmt;
    }
}

SqlStatement updateStmtLimited() :
{
    SqlStatement stmt = null;
}
{
    "UPDATE limi"
    {
        return stmt;
    }
}

void qualifiedTableName() :
{}
{
    "m"}

IndexedBy indexedBy() :
{
    IndexedBy indexed = new IndexedBy();
}
{
    [
	    (
	        "INDEXED" {
	            IndexName ind;
	            indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "BY"
	        ind = indexName() {
	            indexed.setIndex(ind);
	        }
	    |   "NOT" {
                indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "INDEXED" {
            }
	    ) {
            indexed.setEnd(token.endLine, token.endColumn);
            return indexed;
        }
    ] {
        return null;
    }
}

SqlStatement vacuumStmt() :
{
    SqlStatement stmt = null;
}
{
    "VACUUM"
    {
        return stmt;
    }
}

// Functions not mentioned in the specification.
DatabaseName databaseName() :
{
}
{
    "w"
    {
        return null;
    }
}

TableName tableName() :
{
}
{
    "e"
    {
        return null;
    }
}

ConstraintName name() :
{
}
{
    "r" {
        return null;
    }
}

ColumnName columnName() :
{
    
}
{
    "v" {
        return null;
    }
}

TableName foreignTable() :
{
}
{
    "t" {
        return null;
    }
}

CollationName collationName() :
{
}
{
    "y" {
        return null;
    }
}

ConstraintName constraintName() :
{
}
{
    {
        return null;
    }
}