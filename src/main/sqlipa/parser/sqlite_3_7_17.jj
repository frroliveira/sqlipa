options {
    STATIC = false;
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.5";
    IGNORE_CASE = true ;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import java.util.List;
import java.util.LinkedList;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.name.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;

final class ASTParser {

    public static void main(String args[]) {
        ASTParser parser = new ASTParser(System.in);
        try {
            parser.sqlStmt();
            System.out.println("Accept");
        } catch (ParseException e) {
            System.out.println("Reject");
        }
    }

} 
PARSER_END(ASTParser)

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* Keywords */
TOKEN :
{
    <ABORT: "ABORT">
|   <ACTION: "ACTION">
|   <ADD: "ADD">
|   <AFTER: "AFTER">
|   <ALL: "ALL">
|   <ALTER: "ALTER">
|   <ANALYZE: "ANALYZE">
|   <AND: "AND">
|   <AS: "AS">
|   <ASC: "ASC">
|   <ATTACH: "ATTACH">
|   <AUTOINCREMENT: "AUTOINCREMENT">
|   <BEFORE: "BEFORE">
|   <BEGIN: "BEGIN">
|   <BETWEEN: "BETWEEN">
|   <BY: "BY">
|   <CASCADE: "CASCADE">
|   <CASE: "CASE">
|   <CAST: "CAST">
|   <CHECK: "CHECK">
|   <COLLATE: "COLLATE">
|   <COLUMN: "COLUMN">
|   <COMMIT: "COMMIT">
|   <CONFLICT: "CONFLICT">
|   <CONSTRAINT: "CONSTRAINT">
|   <CREATE: "CREATE">
|   <CROSS: "CROSS">
|   <CURRENT_DATE: "CURRENT_DATE">
|   <CURRENT_TIME: "CURRENT_TIME">
|   <CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <DATABASE: "DATABASE">
|   <DEFAULT_: "DEFAULT">
|   <DEFERRABLE: "DEFERRABLE">
|   <DEFERRED: "DEFERRED">
|   <DELETE: "DELETE">
|   <DESC: "DESC">
|   <DETACH: "DETACH">
|   <DISTINCT: "DISTINCT">
|   <DROP: "DROP">
|   <EACH: "EACH">
|   <ELSE: "ELSE">
|   <END: "END">
|   <ESCAPE: "ESCAPE">
|   <EXCEPT: "EXCEPT">
|   <EXCLUSIVE: "EXCLUSIVE">
|   <EXISTS: "EXISTS">
|   <EXPLAIN: "EXPLAIN">
|   <FAIL: "FAIL">
|   <FOR: "FOR">
|   <FOREIGN: "FOREIGN">
|   <FROM: "FROM">
|   <FULL: "FULL">
|   <GLOB: "GLOB">
|   <GROUP: "GROUP">
|   <HAVING: "HAVING">
|   <IF: "IF">
|   <IGNORE: "IGNORE">
|   <IMMEDIATE: "IMMEDIATE">
|   <IN: "IN">
|   <INDEX: "INDEX">
|   <INDEXED: "INDEXED">
|   <INITIALLY: "INITIALLY">
|   <INNER: "INNER">
|   <INSERT: "INSERT">
|   <INSTEAD: "INSTEAD">
|   <INTERSECT: "INTERSECT">
|   <INTO: "INTO">
|   <IS: "IS">
|   <ISNULL: "ISNULL">
|   <JOIN: "JOIN">
|   <KEY: "KEY">
|   <LEFT: "LEFT">
|   <LIKE: "LIKE">
|   <LIMIT: "LIMIT">
|   <MATCH: "MATCH">
|   <NATURAL: "NATURAL">
|   <NO: "NO">
|   <NOT: "NOT">
|   <NOTNULL: "NOTNULL">
|   <NULL: "NULL">
|   <OF: "OF">
|   <OFFSET: "OFFSET">
|   <ON: "ON">
|   <OR: "OR">
|   <ORDER: "ORDER">
|   <OUTER: "OUTER">
|   <PLAN: "PLAN">
|   <PRAGMA: "PRAGMA">
|   <PRIMARY: "PRIMARY">
|   <QUERY: "QUERY">
|   <RAISE: "RAISE">
|   <REFERENCES: "REFERENCES">
|   <REGEXP: "REGEXP">
|   <REINDEX: "REINDEX">
|   <RELEASE: "RELEASE">
|   <RENAME: "RENAME">
|   <REPLACE: "REPLACE">
|   <RESTRICT: "RESTRICT">
|   <RIGHT: "RIGHT">
|   <ROLLBACK: "ROLLBACK">
|   <ROW: "ROW">
|   <SAVEPOINT: "SAVEPOINT">
|   <SELECT: "SELECT">
|   <SET: "SET">
|   <TABLE: "TABLE">
|   <TEMP: "TEMP">
|   <TEMPORARY: "TEMPORARY">
|   <THEN: "THEN">
|   <TO: "TO">
|   <TRANSACTION: "TRANSACTION">
|   <TRIGGER: "TRIGGER">
|   <UNION: "UNION">
|   <UNIQUE: "UNIQUE">
|   <UPDATE: "UPDATE">
|   <USING: "USING">
|   <VACUUM: "VACUUM">
|   <VALUES: "VALUES">
|   <VIEW: "VIEW">
|   <VIRTUAL: "VIRTUAL">
|   <WHEN: "WHEN">
|   <WHERE: "WHERE">
}

/* Operators */
TOKEN :
{
    <CONCATENATION: "||">
|   <STAR: "*">
|   <SLASH: "/">
|   <MODULO: "%">
|   <PLUS: "+">
|   <MINUS: "-">
|   <SHIFT_HIGH: "<<">
|   <SHIFT_LOW: ">>">
|   <BIT_AND: "&">
|   <BIT_OR: "|">
|   <BIT_NOT: "~">
|   <LESS: "<">
|   <LESS_OR_EQUAL: "<=">
|   <GREATER: ">">
|   <GREATER_OR_EQUAL: ">=">
|   <EQUAL_1: "=">
|   <EQUAL_2: "==">
|   <NOT_EQUAL_1: "!=">
|   <NOT_EQUAL_2: "<>">
}

/* Separators */
TOKEN :
{
  < LP: "(" >
| < RP: ")" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* Char Sets */
TOKEN :
{
    <DIGIT: ["0" - "9"]>
    // Has mentioned in sqlite implementation '$' is not documented but is
    // implemented for compatibility.
|   <CHAR: ["A" - "Z", "_", "$"]>
|   <HEX_CHAR: ["0" - "9", "A" - "F"]>
}

/* Literals && Identifiers */
TOKEN :
{
    <NUMERIC:
        (
            (<DIGIT>)+ (<DOT> (<DIGIT>)*)?
        |   <DOT> (<DIGIT>)+
        )
        (<EXPONENT>)?
    >
|   <EXPONENT: "E" (["+", "-"])? (<DIGIT>)+>
|   <STRING: "'" (~["'"])* ("''" (~["'"])*)* "'">
|   <BLOB: "X'" (<HEX_CHAR> <HEX_CHAR>)* "'">
|   <PARAMETER: 
        "?" (<DIGIT>)*
    |   (":" | "@" | "$") // sqlite implementation also allows '#'.
        ("::")?
        <CHAR>
        (<CHAR> | "::")*
        (
            "("
            (~[")", "\u0009", "\n", "\u000b", "\u000c", "\r", "\u0020"])*
            ")"
        )?
    >
|   <ID: 
        <CHAR> (<CHAR> | <DIGIT>)*
    |   "\"" (~["\""])* ("\"\"" (~["\""])*)* "\""
    |   "`" (~["`"])* ("``" (~["`"])*)* "`"
    |   "[" (~["]"])* "]"
    >
}

/* Comments */
SPECIAL_TOKEN :
{
    <LINE_COMMENT: "--" (~["\n"])* "\n">
}

MORE :
{
    "/*": IN_BLOCK_COMMENT
}

<IN_BLOCK_COMMENT> MORE :
{
    <~[]>
}

<IN_BLOCK_COMMENT> SPECIAL_TOKEN :
{
    <BLOCK_COMMENT: "*/">: DEFAULT
}

TOKEN_MGR_DECLS :
{
    private List<Comment> comments = new LinkedList<Comment>();
    
    private void CommonTokenAction(Token token) {
        token = token.specialToken;
        while (token != null) {
            if (token.kind == LINE_COMMENT) {
                comments.add(new LineComment(new Block(token.beginLine,
                    token.beginColumn, token.endLine, token.endColumn), 
                    token.image));
            } else if (token.kind == BLOCK_COMMENT) {
                comments.add(new BlockComment(new Block(token.beginLine,
                    token.beginColumn, token.endLine, token.endColumn), 
                    token.image));
            } else {
                break;
            }
            token = token.specialToken;
        }
    }
    
    public List<Comment> popComments() {
        List<Comment> ret = comments;
        comments = new LinkedList<Comment>();
        return ret;
    }
    
    public List<Comment> peekComments() {
        return comments;
    }
}

/* Grammar */
List<SqlStatement> sqlStmtList() :{
    List<SqlStatement> stmts = new LinkedList<SqlStatement>();    SqlStatement stmt;
}
{
    (
        stmt = sqlStmt() {
            stmts.add(stmt);
        }
    )* {
        return stmts;
    }
}

SqlStatement sqlStmt() :
{
    int line = 0;
    int column = 0;
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            line = token.beginLine;
            column = token.beginColumn;
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    (/*
        stmt = alterTableStmt()
    |   stmt = analyzeStmt()
    |   stmt = attachStmt()
	|   stmt = beginStmt()
	|   stmt = commitStmt()
	|   stmt = createIndexStmt()
	|*/   stmt = createTableStmt() /*
	|   stmt = createTriggerStmt()
	|   stmt = createViewStmt()
	|   stmt = createVirtualTableStmt()	|   stmt = deleteStmt()
	|   stmt = deleteStmtLimited()
	|   stmt = detachStmt()
	|   stmt = dropIndexStmt()
	|   stmt = dropTableStmt()
	|   stmt = dropTriggerStmt()
	|   stmt = dropViewStmt()
	|   stmt = insertStmt()
	|   stmt = pragmaStmt()
	|   stmt = reindexStmt()
	|   stmt = releaseStmt()
	|   stmt = rollbackStmt()
	|   stmt = savepointStmt()
	|*/   stmt = selectStmt() /*
	|   stmt = updateStmt()
	|   stmt = updateStmtLimited()
	|   stmt = vacuumStmt()*/
	) {
        if (explain != null) {
            // If statement starts by EXPLAIN.
            stmt.setBegin(line, column);
            stmt.setExplain(explain);
        }
        return stmt;
    }
}

IndexedColumn indexedColumn() :
{
    IndexedColumn indColumn = new IndexedColumn();
    ColumnName column;
}
{
    column = columnName() {
        indColumn.setColumn(column);
        indColumn.setBegin(column);
    }
    [
        "COLLATE" {
            CollationName collation;
        }
        collation = collationName() {
            indColumn.setCollation(collation);
        }
    ]
    [
        "ASC" {
            indColumn.setOrder(IndexedColumn.Order.ASC);
        }
    |   "DESC" {
            indColumn.setOrder(IndexedColumn.Order.DESC);
        }
    ] {
        indColumn.setEnd(token.endLine, token.endColumn);
        return indColumn;
    }}

CreateTableStmt createTableStmt() :
{
    CreateTableStmt stmt;
    int line;
    int column;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    DatabaseName db = null;
    TableName tab;
}
{
    "CREATE" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        db = databaseName() "."
    ]
    tab = tableName()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.setTemporary(hasTemp);
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(tab);
        stmt.setDatabase(db);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(columnDef());
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHAED(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        "," 
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," {
            TableConstraint constraint;
        }
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmtWithSelect createTableStmtWithSelect() :
{
    SelectStmt select;
}
{
    "AS"
    select = selectStmt() {
        return new CreateTableStmtWithSelect(select);
    }
}

ColumnDef columnDef() :
{
    ColumnDef columnDef = new ColumnDef();
    ColumnName column;
    TypeName type;
    ColumnConstraint constraint;}
{
    column = columnName() {
        columnDef.setColumn(column);
        columnDef.setBegin(column);
    }
    [
        type = typeName() {
            columnDef.setType(type);
        }
    ]
    (
        constraint = columnConstraint() {
            columnDef.addConstraint(constraint);
        }
    )* {
        columnDef.setEnd(token.endLine, token.endColumn);
        return columnDef;
    }}

TypeName typeName() :
{
    TypeName type = new TypeName();
    String name = new String();
    
    type.setName(name);}
{
    name() {
        type.setBegin(token.beginLine, token.beginColumn);
        name += token.image;
    }
    (
        name() {
            name += " " + token.image;
        }
    )*
    [
        "(" {
            UnaryExpr xDim;
        }
        xDim = signedNumber() {
            type.setDimensionInX(xDim);
        }
        [
            "," {
                UnaryExpr yDim;
            }
            yDim = signedNumber() {
                type.setDimensionInY(yDim);
            }
        ]
        ")"
    ] {
        type.setEnd(token.endLine, token.endColumn);
        return type;
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    int line = 0;
    int column = 0;
    ConstraintName name = null;}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyColumnConstraint()
    |   constraint = notNullColumnConstraint()
    |   constraint = uniqueColumnConstraint()
    |   constraint = checkColumnConstraint()
    |   constraint = defaultColumnConstraint()    |   constraint = collateColumnConstraint()
    |   constraint = foreignKeyColumnConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint() :
{
    PrimaryKeyColumnConstraint constraint = new PrimaryKeyColumnConstraint();
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        "ASC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.ASC);
        }
    |   "DESC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.DESC);
        }
    ]
    clause = conflictClause() {
        constraint.setClause(clause);
    }
    [
        "AUTOINCREMENT" {
            constraint.setAutoincrement(true);
        }
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

NotNullColumnConstraint notNullColumnConstraint() :
{
    NotNullColumnConstraint constraint = new NotNullColumnConstraint();
    ConflictClause clause;
}
{
    "NOT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueColumnConstraint uniqueColumnConstraint() :
{
    UniqueColumnConstraint constraint = new UniqueColumnConstraint();
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckColumnConstraint checkColumnConstraint() :
{
    CheckColumnConstraint constraint = new CheckColumnConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    expr = expr()
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

DefaultColumnConstraint defaultColumnConstraint() :
{
    DefaultColumnConstraint constraint = new DefaultColumnConstraint();
    Expression expr;
    Literal literal;
}
{
    "DEFAULT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    (
        // As signedNumber and literalValue match a numericLiteral() it is only
        // consider to exist a signedNumber if actually there is sign.
        LOOKAHEAD("+" | "-")
        expr = signedNumber()
    |   literal = literalValue() {
            expr = new LiteralExpr(literal, literal);
        }
    |   "("
        expr = expr()
        ")"
    ) {
        constraint.setEnd(token.endLine, token.endColumn);
        constraint.setExpression(expr);
        return constraint;
    }
}

CollateColumnConstraint collateColumnConstraint() :
{
    CollateColumnConstraint constraint = new CollateColumnConstraint();
    CollationName collation;
}
{
    "COLLATE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    collation = collationName() {
        constraint.setCollation(collation);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint() :
{
    ForeignKeyColumnConstraint constraint = new ForeignKeyColumnConstraint();
    ForeignKeyClause clause;
}
{
    clause = foreignKeyClause() {
        constraint.setBeginEnd(clause);
        constraint.setClause(clause);
        return constraint;
    }
}

UnaryExpr signedNumber() :
{
    UnaryExpr number = new UnaryExpr();
    NumericLiteral literal;}
{
    [
        (
            "+" {
                number.setOperator(UnaryExpr.Operator.POSITIVE);
            }
        |   "-" {
                number.setOperator(UnaryExpr.Operator.NEGATIVE);
            }
        ) {
            number.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        if (number.getOperator() == null) {
            number.setBeginEnd(literal);
        } else {
            number.setEnd(token.endLine, token.endColumn);
        }
        number.setExpression(new LiteralExpr(literal, literal));
        return number;
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    int line = 0;
    int column = 0;
    ConstraintName name = null;
}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = constraintName()
    ]
    (
        constraint = primaryKeyTableConstraint()
    |   constraint = checkTableConstraint()
    |   constraint = foreignKeyTableConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint() :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint() :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint() :
{
    CheckTableConstraint constraint = new CheckTableConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() 
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint() :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    ColumnName column;
    ForeignKeyClause clause;
}
{
    "FOREIGN" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = columnName() {
        constraint.addColumn(column);
    }
    (
        "," 
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = foreignKeyClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{
    ForeignKeyClause clause = new ForeignKeyClause();
    Block block = new Block();
    TableName tab;
    ForeignKeySetting sett;}
{
    "REFERENCES" {
        clause.setBegin(token.beginLine, token.beginColumn);
    }
    tab = tableName() {
        clause.setTable(tab);
    }
    [
        "(" {
            ColumnName column;
        }
        column = columnName() {
            clause.addColumn(column);
        }
        (
            ","
            column = columnName() {
                clause.addColumn(column);
            }
        )*
        ")"
    ]
    (
        sett = onForeignKeySett() {
            clause.addSetting(sett);
        }
    |   sett = matchForeignKeySett() {
            clause.addSetting(sett);
        }
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
        sett = deferrableForeignKeySett() {
            clause.addSetting(sett);
        }
    ] {
        clause.setEnd(token.endLine, token.endColumn);
        return clause;
    }}

OnForeignKeySett onForeignKeySett() :
{
    OnForeignKeySett sett = new OnForeignKeySett();
}
{
    "ON" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    (
        "DELETE" {
            sett.setEvent(OnForeignKeySett.Event.DELETE);
        }
    |   "UPDATE" {
            sett.setEvent(OnForeignKeySett.Event.UPDATE);
        }
    )
    (
        "SET"
        (
            "NULL" {
                sett.setAction(OnForeignKeySett.Action.SET_NULL);
            }
        |   "DEFAULT" {
                sett.setAction(OnForeignKeySett.Action.SET_DEFAULT);
            }
        )
    |   "CASCADE" {
            sett.setAction(OnForeignKeySett.Action.CASCADE);
        }
    |   "RESTRICT" {
            sett.setAction(OnForeignKeySett.Action.RESTRICT);
        }
    |   "NO" "ACTION" {
            sett.setAction(OnForeignKeySett.Action.NO_ACTION);
        }
    ) {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

MatchForeignKeySett matchForeignKeySett() :
{
    MatchForeignKeySett sett = new MatchForeignKeySett();
}
{
    "MATCH" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    name() {
        sett.setName(new Name(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image));
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

DeferrableForeignKeySett deferrableForeignKeySett() :
{
    DeferrableForeignKeySett sett = new DeferrableForeignKeySett();
}
{
    (
        "NOT" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.NOT_DEFERRABLE);
        }
        "DEFERRABLE"
    |   "DEFERRABLE" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableForeignKeySett.Type.DEFERRABLE);
        }
    )
    [
        "INITIALLY"
        (
            "DEFERRED" {
                sett.setMode(DeferrableForeignKeySett.Mode.DEFERRED);
            }
        |   "IMMEDIATE" {
                sett.setMode(DeferrableForeignKeySett.Mode.IMMEDIATE);
            }
        )
    ] {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

ConflictClause conflictClause() :
{
}
{
    [   
        "ON" {
            ConflictClause clause = new ConflictClause();
            clause.setBegin(token.beginLine, token.beginColumn);
        }
        "CONFLICT"
        (
            "ROLLBACK" {
                clause.setAction(ConflictClause.Action.ROLLBACK);
            }
        |   "ABORT" {
                clause.setAction(ConflictClause.Action.ABORT);
            }
        |   "FAIL" {
                clause.setAction(ConflictClause.Action.FAIL);
            }
        |   "IGNORE" {
                clause.setAction(ConflictClause.Action.IGNORE);
            }
        |   "REPLACE" {
                clause.setAction(ConflictClause.Action.REPLACE);
            }
        ) {
            clause.setEnd(token.endLine, token.endColumn);
            return clause;
        }
    ] {
        return null;
    }}

// Expression is built by parts recursively to ensure operator precedences are
// to avoid left recursion.
Expression expr() :
{
    Expression left;
    Expression right;
}
{
    left = andExpr()   
    (
        "OR"
        right = andExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.OR);
        }
    )* {
        return left;
    }
}

Expression andExpr() :
{
    Expression left;
    Expression right;
}
{
    left = notExpr()
    (
        "AND"
        right = notExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.AND);
        }
    )* {
        return left;
    }
}

Expression notExpr() :
{
    Expression expr;
}
{
    (
        "NOT" {
            int line = token.beginLine;
            int column = token.beginColumn;
        }
        expr = notExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), UnaryExpr.Operator.LOGICAL_NOT, expr);
        }
    |   expr = equalityExpr() 
    ) {
        return expr;
    }
}

Expression equalityExpr() :
{
    Expression expr;
}
{
    expr = relationalExpr()
    // All types of expressions in this choice point can start by "NOT". 
    // LOOKAHEAD removes ambiguity which one to choose.
    (
        LOOKAHEAD(2)
        expr = unaryEqualityExpr(expr)
    |   LOOKAHEAD(2)
        expr = betweenExpr(expr)
    |   LOOKAHEAD(2)
        expr = inExpr(expr)
    |   expr = binaryEqualityExpr(expr)
    )* {
        return expr;
    }
}

Expression unaryEqualityExpr(Expression expr) :
{
    UnaryExpr.Operator op;
}
{
    (
        "ISNULL" {
            op = UnaryExpr.Operator.IS_NULL;
        }
    |   "NOTNULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    |   "NOT" "NULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    ) {
        return new UnaryExpr(new Block(expr.beginLine, expr.beginColumn,
            token.endLine, token.endColumn), op, expr);
    }
}

Expression binaryEqualityExpr(Expression left) :
{
    Expression right;
    BinaryExpr.Operator op;
}
{
    op = binaryEqualityOperator()
    right = relationalExpr() {
        return new BinaryExpr(new Block(left.beginLine, left.beginColumn,
            token.endLine, token.endColumn), left, right, op);
    }
}

BinaryExpr.Operator binaryEqualityOperator() :
{
}
{
    "=" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "==" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "!=" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "<>" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "IS"
    [
        "NOT" {
            return BinaryExpr.Operator.IS_NOT;
        }
    ] {
        return BinaryExpr.Operator.IS;
    }
|   "NOT"
    (
        "LIKE" {
            return BinaryExpr.Operator.NOT_LIKE;
        }
    |   "GLOB" {
            return BinaryExpr.Operator.NOT_GLOB;
        }
    |   "REGEXP" {
            return BinaryExpr.Operator.NOT_REGEXP;
        }
    |   "MATCH" {
            return BinaryExpr.Operator.NOT_MATCH;
        }
    )
|   "LIKE" {
        return BinaryExpr.Operator.LIKE;
    }
|   "GLOB" {
        return BinaryExpr.Operator.GLOB;
    }
|   "REGEXP" {
        return BinaryExpr.Operator.REGEXP;
    }
|   "MATCH" {
        return BinaryExpr.Operator.MATCH;
    }
}

BetweenExpr betweenExpr(Expression expr) :
{
    BetweenExpr between = new BetweenExpr();
    
    between.setExpression(expr);
    between.setBegin(expr);
}
{
    (
        "NOT" "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.NOT_BETWEEN);
        }
    |   "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.BETWEEN);
        }
    )
    expr = relationalExpr() {
        between.setLower(expr);
    }
    "AND"
    expr = relationalExpr() {
        between.setUpper(expr);
        between.setEnd(token.endLine, token.endColumn);
        return between;
    }
}

InExpr inExpr(Expression expr) :
{
    InExpr in = null;
    InExpr.Operator op;
}
{
    (
        "NOT" "IN" {
            op = InExpr.Operator.NOT_IN;
        }
    |   "IN" {
            op = InExpr.Operator.IN;
        }
    )
    (
        "("
        [
            in = inSelectExpr()
        |   in = inSetExpr()
        ] {
            if (in == null) {
                in = new InSetExpr();
            }
        }
        ")"
    |   in = inTableExpr()
    ) {
        in.setExpression(expr);
        in.setOperator(op);
        in.setBegin(expr);
        in.setEnd(token.endLine, token.endColumn);
        return in;
    }
}

InSelectExpr inSelectExpr() :
{
    SelectStmt stmt;
}
{
    stmt = selectStmt() {
        InSelectExpr in = new InSelectExpr();
        in.setStatement(stmt);
        return in;
    }
}

InSetExpr inSetExpr() :
{
    InSetExpr in = new InSetExpr();
    Expression expr;
}
{
    expr = expr() {
        in.addExpression(expr);
    }
    (
        ","
        expr = expr() {
            in.addExpression(expr);
        }
    )* {
        return in;
    }
}

InTableExpr inTableExpr() :
{
    InTableExpr in = new InTableExpr();
    DatabaseName db = null;
    TableName tab;
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        db = databaseName() {
            in.setDatabase(db);
        }
        "."
    ]
    tab = tableName() {
        in.setTable(tab);
        return in;
    }
}

Expression relationalExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = escapeExpr()
    (
        (
            "<" {
                op = BinaryExpr.Operator.LESS;
            }
        |   "<=" {
                op = BinaryExpr.Operator.LESS_OR_EQUAL;
            }
        |   ">" {
                op = BinaryExpr.Operator.GREATER;
            }
        |   ">=" {
                op = BinaryExpr.Operator.GREATER_OR_EQUAL;
            }
        )
        right = escapeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression escapeExpr() :
{
    Expression left;
    Expression right;
}
{
    left = bitwiseExpr()
    [
        "ESCAPE"
        right = bitwiseExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.ESCAPE);
        }
    ] {
        return left;
    }
}

Expression bitwiseExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = additiveExpr()
    (
        op = bitwiseOperator()
        right = additiveExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

BinaryExpr.Operator bitwiseOperator() :
{
}
{
    ">>" {
        return BinaryExpr.Operator.SHIFT_HIGH;
    }
|   "<<" {
        return BinaryExpr.Operator.SHIFT_LOW;
    }
|   "&" {
        return BinaryExpr.Operator.BIT_AND;
    }
|   "|" {
        return BinaryExpr.Operator.BIT_OR;
    }
}

Expression additiveExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = multiplicativeExpr()
    (
        (
            "+" {
                op = BinaryExpr.Operator.ADDITION;
            }
        |   "-" {
                op = BinaryExpr.Operator.SUBTRACTION;
            }
        )
        right = multiplicativeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression multiplicativeExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = concatenateExpr()
    (
        (
            "*" {
                op = BinaryExpr.Operator.MULTIPLICATION;
            }
        |   "/" {
                op = BinaryExpr.Operator.DIVISION;
            }
        |   "%" {
                op = BinaryExpr.Operator.MODULO;
            }
        )
        right = concatenateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression concatenateExpr() :
{
    Expression left;
    Expression right;
}
{
    left = collateExpr()
    (
        "||"
        right = collateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.CONCATENATION);
        }
    )* {
        return left;
    }
}

Expression collateExpr() :
{
    Expression expr;
    CollationName collation;
}
{
    expr = unaryExpr()
    (
        "COLLATE"
        collation = collationName() {
            expr = new CollateExpr(new Block(expr.beginLine, expr.beginColumn,
                token.endLine, token.endColumn), expr, collation);
        }
    )* {
        return expr;
    }
}

Expression unaryExpr() :
{
    Expression expr;
    UnaryExpr.Operator op;
}
{
    (   
	    op = unaryOperator() {
	        int line = token.beginLine;
	        int column = token.beginColumn;
	    }
        expr = unaryExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), op, expr);
        }
    |   expr = terminalExpr()
    ) {
        return expr;
    }
}

UnaryExpr.Operator unaryOperator() :
{
}
{
    "-" {
        return UnaryExpr.Operator.NEGATIVE;
    }
|   "+" {
        return UnaryExpr.Operator.POSITIVE;
    }
|   "~" {
        return UnaryExpr.Operator.BIT_NOT;
    }
}

Expression terminalExpr() :
{
    Expression expr;
}
{
    (
        expr = literalExpr()
    |   expr = bindParameterExpr()
    |   LOOKAHEAD(2) // columnExpr also starts with a name.
        expr = functionExpr()
    |   expr = columnExpr()
    |   expr = castExpr()
    |   expr = existsExpr()
    |   LOOKAHEAD(2) // selectExpr also starts by "(".
        "(" expr = expr() ")"
    |   expr = selectExpr()
    |   expr = caseExpr()
    |   expr = raiseFunctionExpr()
    ) {
        return expr;
    }
}

LiteralExpr literalExpr() :
{
    Literal literal;
}
{
    literal = literalValue() {
        return new LiteralExpr(new Block(literal), literal);
    }
}

ColumnExpr columnExpr() :
{
    ColumnExpr reference = new ColumnExpr();
    DatabaseName db = null;
    TableName tab = null;
    ColumnName column;
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        [
            LOOKAHEAD(4) // Anticipate the occurrence of a dot.
            db = databaseName() {
                reference.setDatabase(db);
                reference.setBegin(db);
            }
            "."
        ]
        tab = tableName() {
            reference.setTable(tab);
            if (db == null) {
                reference.setBegin(tab);
            }
        }
        "."
    ]
    column = columnName() {
        reference.setColumn(column);
        if (column == null) {
            reference.setBegin(column);
        }
        reference.setEnd(token.endLine, token.endColumn);
        return reference;
    }
}

CastExpr castExpr() :
{
    CastExpr cast = new CastExpr();
    Expression expr;
    TypeName type;
}
{
    "CAST" {
        cast.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() {
        cast.setExpression(expr);
    }
    "AS"
    type = typeName() {
        cast.setType(type);
    }
    ")" {
        cast.setEnd(token.endLine, token.endColumn);
        return cast;
    }
}

UnaryExpr existsExpr() :
{
    UnaryExpr exists = new UnaryExpr();
    Expression expr;
}
{
    "EXISTS" {
        exists.setBegin(token.beginLine, token.beginColumn);
    }
    expr = selectExpr() {
        exists.setExpression(expr);
        exists.setOperator(UnaryExpr.Operator.EXISTS);
        exists.setEnd(token.endLine, token.endColumn);
        return exists;
    }
}

SelectExpr selectExpr() :
{
    SelectExpr expr = new SelectExpr();
    SelectStmt stmt;
}
{
    "(" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt()
    ")" {
        expr.setStatement(stmt);
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

CaseExpr caseExpr() :
{
    CaseExpr caseExpr = new CaseExpr();
    Expression expr;
    WhenExpr when;
}
{
    "CASE" {
        caseExpr.setBegin(token.beginLine, token.beginColumn);
    }
    [
        expr = expr() {
            caseExpr.setCase(expr);
        }
    ]
    (
        when = whenExpr() {
            caseExpr.addWhen(when);
        }
    )+
    [
        "ELSE"
        expr = expr() {
            caseExpr.setElse(expr);
        }
    ]
    "END" {
        caseExpr.setEnd(token.endLine, token.endColumn);
        return caseExpr;
    }
}

WhenExpr whenExpr() :
{
    WhenExpr when = new WhenExpr();
    Expression expr;
}
{
    "WHEN" {
        when.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        when.setWhen(expr);
    }
    "THEN"
    expr = expr() {
        when.setThen(expr);
        when.setEnd(token.endLine, token.endColumn);
        return when;
    }
}

RaiseFunctionExpr raiseFunctionExpr() :
{
    RaiseFunctionExpr expr = new RaiseFunctionExpr();
}
{
    "RAISE" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    (
        "IGNORE" {
            expr.setType(RaiseFunctionExpr.Type.IGNORE);
        }
    |   (
            "ROLLBACK" {
                expr.setType(RaiseFunctionExpr.Type.ROLLBACK);
            }
        |   "ABORT" {
                expr.setType(RaiseFunctionExpr.Type.ABORT);
            }
        |   "FAIL" {
                expr.setType(RaiseFunctionExpr.Type.FAIL);
            }
        )
        ","
        (
            <ID>
        |   <STRING>
        ) {
            expr.setError(token.image);
        }
    )
    ")" {
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

FunctionExpr functionExpr() :
{
    FunctionExpr function = new FunctionExpr();
    FunctionName name;
    Expression expr;
}
{
    name = functionName() {
        function.setFunction(name);
        function.setBegin(name);
    }
    "("
    [
        "*" {
            function.setOperator(FunctionExpr.Operator.UNIVERSAL);
        }
    |   [
            "DISTINCT" {
                function.setOperator(FunctionExpr.Operator.DISTINCT);
            }
        ]
        expr = expr() {
            function.addExpression(expr);
        }
        (
            ","
            expr = expr() {
                function.addExpression(expr);
            }
        )* // TODO: create expression list
    ]
    ")" {
        function.setEnd(token.endLine, token.endColumn);
        return function;
    }
}

SelectStmt selectStmt() :
{
    SelectStmt stmt = new SelectStmt();
    SelectUnit unit;
    SelectCompound.Operator op;
    SelectUnit core;
}
{
    unit = selectCore() {
        stmt.setBegin(unit);
    }
    (
        op = compoundOperator()
        core = selectCore() {
            unit = new SelectCompound(new Block(unit.beginLine, 
                unit.beginColumn, token.endLine, token.endColumn), unit, core,
                op);
        }
    )* {
        stmt.setUnit(unit);
    }
    [
        "ORDER" "BY" {
            OrderingTerm term;
        }
        term = orderingTerm() {
            stmt.addTerm(term);
        }
        (
            ","
            term = orderingTerm() {
                stmt.addTerm(term);
            }
        )*
    ]
    [
        "LIMIT" {
            Expression expr;
        }
        expr = expr() {
            stmt.setLimit(expr);
        }
        [
            ( "OFFSET" | "," )
            expr = expr() {
                stmt.setOffset(expr);
            }
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SelectCore selectCore() :
{
    SelectCore core = new SelectCore();
    ResultColumn column;}
{
    "SELECT" {
        core.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DISTINCT" {
            core.setDistinct(true);
        }
    |   "ALL"
    ]
    column = resultColumn() {
        core.addColumn(column);
    }
    (
        ","
        resultColumn() {
	        core.addColumn(column);
	    }
    )*
    [
        "FROM" {
            JoinSrc src;
        }
        src = joinSource() {
            core.setFrom(src);
        }
    ]
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            core.setWhere(expr);
        }
    ]
    [
        "GROUP" "BY" {
            Expression expr;
        }
        expr = expr() {
            core.addGroupByExpression(expr);
        }
        (
            ","
            expr = expr() {
                core.addGroupByExpression(expr);
            }
        )*
        [
            "HAVING"
            expr = expr() {
                core.setHaving(expr);
            }
        ]
    ] {
        core.setEnd(token.endLine, token.endColumn);
        return core;
    }
}

ResultColumn resultColumn() :
{
    ResultColumn column;}
{
    (
        LOOKAHEAD(3) // Removes ambiguity between "tab.*" and "tab.column".
        column = universalColumn()
    |   column = expressionColumn()
    ) {
        return column;
    }}

UniversalColumn universalColumn() :
{
    UniversalColumn column = new UniversalColumn();
    TableName tab;
}
{
    (
        "*" {
            column.setBeginEnd(token.beginLine, token.beginColumn,
                token.endLine, token.endColumn);
        }
    |   tab = tableName() {
            column.setTable(tab);
        }
        "." 
        "*" {
            column.setBeginEnd(tab.beginLine, tab.beginColumn, token.endLine,
                token.endColumn);
        }
    ) {
        return column;
    }
}

ExpressionColumn expressionColumn() :
{
    ExpressionColumn column = null;
    Expression expr;
}
{
    expr = expr()
    [
        column = aliasedColumn()
    ] {
        if (column == null) {
            column = new ExpressionColumn();
        }
        column.setExpression(expr);
        column.setBeginEnd(expr.beginLine, expr.beginColumn, token.endLine,
            token.endColumn);
        return column;
    }
}

AliasedColumn aliasedColumn() :
{
    AliasedColumn column = new AliasedColumn();
    ColumnAlias alias;
}
{
	[ "AS" ]
	alias = columnAlias() {
	    column.setAlias(alias);
	    return column;
	}
}

JoinSrc joinSource() :
{
    JoinSrc src;
    JoinCompound.Operator op;
    JoinSrc right;
    JoinConstraint constraint;}
{
    src = singleSource()
    (
        op = joinOp()
        right = singleSource()
        constraint = joinConstraint() {
            src = new JoinCompound(new Block(src.beginLine, src.beginColumn,
                token.endLine, token.endColumn), src, right, op, constraint);
        }
    )* {
        return src;
    }}

JoinSrc singleSource() :
{
    JoinSrc src;
    int line = 0;
    int column = 0;}
{
    (
        src = tableSource()
    |   // To remove ambiguity between selectSource and the joinSource because 
        // both start by "(".
        LOOKAHEAD(2)
        src = selectSource()
    |   "(" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        src = joinSource()
        ")" {
            src.setBeginEnd(line, column, token.endLine, token.endColumn);
        }
    ) {
        return src;
    }}

TableSrc tableSource() :
{
    TableSrc src = new TableSrc();
    DatabaseName db = null;
    TableName tab;
    IndexedBy indexed;
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        db = databaseName() {
            src.setDatabase(db);
            src.setBegin(db);
        }
        "."
    ]
    tab = tableName() {
        src.setTable(tab);
        if (db == null) {
            src.setBegin(tab);
        }
    }
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ]
    indexed = indexedBy() {
        src.setIndexed(indexed);
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

SelectSrc selectSource() :
{
    SelectSrc src = new SelectSrc();
    SelectStmt stmt;
}
{
    "(" {
        src.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt() {
        src.setStatement(stmt);
    }
    ")"
    [
        [ "AS" ] {
            TableAlias alias;
        }
        alias = tableAlias() {
            src.setAlias(alias);
        }
    ] {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

JoinCompound.Operator joinOp() :
{}
{
    "," {
        return JoinCompound.Operator.COMMA;
    }
|   "NATURAL" 
    (
        "LEFT" 
        (
            "OUTER" "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_OUTER_JOIN;	        }
	    |   "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_JOIN;
	        }
        )
    |   "INNER" "JOIN" {
            return JoinCompound.Operator.NATURAL_INNER_JOIN;
        }
    |   "CROSS" "JOIN" {
            return JoinCompound.Operator.NATURAL_CROSS_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.NATURAL_JOIN;
        }
    )
|   "LEFT" 
    (
        "OUTER" "JOIN" {
            return JoinCompound.Operator.LEFT_OUTER_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.LEFT_JOIN;
        }
    )
|   "INNER" "JOIN" {
        return JoinCompound.Operator.INNER_JOIN;
    }
|   "CROSS" "JOIN" {
        return JoinCompound.Operator.CROSS_JOIN;
    }
|   "JOIN" {
        return JoinCompound.Operator.JOIN;
    }
}

JoinConstraint joinConstraint() :
{
    JoinConstraint constraint = null;}
{
    [
        constraint = joinConstraintOn()
    |   constraint = joinConstraintUsing()
    ] {
        return constraint;
    }}

JoinConstraintOn joinConstraintOn() :
{
    JoinConstraintOn constraint = new JoinConstraintOn();
    Expression expr;
}
{
    "ON" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

JoinConstraintUsing joinConstraintUsing():
{
    JoinConstraintUsing constraint = new JoinConstraintUsing();
    ColumnName column;
}
{
    "USING" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
	"("
	column = columnName() {
        constraint.addColumn(column);
    }
    (
        ","
        column = columnName() {
            constraint.addColumn(column);
        }
    )*
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

OrderingTerm orderingTerm() :
{
    OrderingTerm term = new OrderingTerm();
    Expression expr;}
{
    expr = expr() {
        term.setBegin(expr);
        term.setExpression(expr);
    }
    [
        "ASC" {
            term.setOrder(OrderingTerm.Order.ASC);
        }
    |   "DESC" {
            term.setOrder(OrderingTerm.Order.DESC);
        }
    ] {
        term.setEnd(token.endLine, token.endColumn);
        return term;
    }}

SelectCompound.Operator compoundOperator() :
{
}
{
    "UNION" 
    [ 
        "ALL" {
            return SelectCompound.Operator.UNION_ALL;
        }
    ] {
        return SelectCompound.Operator.UNION;
    }
|   "INTERSECT" {
        return SelectCompound.Operator.INTERSECT;
    }
|   "EXCEPT" {
        return SelectCompound.Operator.EXCEPT;
    }
}

IndexedBy indexedBy() :
{
    IndexedBy indexed = new IndexedBy();
}
{
    [
	    (
	        "INDEXED" {
	            IndexName ind;
	            indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "BY"
	        ind = indexName() {
	            indexed.setIndex(ind);
	        }
	    |   "NOT" {
                indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "INDEXED"
	    ) {
            indexed.setEnd(token.endLine, token.endColumn);
            return indexed;
        }
    ] {
        return null;
    }
}

Literal literalValue() :
{
    Literal literal;
}
{
    (
        literal = numericLiteral()
    |   literal = stringLiteral()
    |   literal = blobLiteral()
    |   (
            "NULL"
	    |   "CURRENT_TIME"
	    |   "CURRENT_DATE"
	    |   "CURRENT_TIMESTAMP"
	    ) {
	       literal = new Literal(new Block(token.beginLine, token.beginColumn,
	           token.endLine, token.endColumn), token.image);
	    }
    ) {
        return literal;
    }
}

NumericLiteral numericLiteral() :
{
}
{
    <NUMERIC> {
        return new NumericLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

StringLiteral stringLiteral() :
{
}
{
    <STRING> {
        return new StringLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

BlobLiteral blobLiteral() :
{
}
{
    <BLOB> {
        return new BlobLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

BindParameterExpr bindParameterExpr() :
{
}
{
    <PARAMETER> {
        return new BindParameterExpr(new Block(token.beginLine, 
            token.beginColumn, token.endLine, token.endColumn), token.image);
    }
}

// Names
void name() :
{
}
{
    // sqlite implementation allows it to be a string also. That would
    // introduce syntactic ambiguity in spite of not being semantically
    // ambiguous.
    <ID>
}

DatabaseName databaseName() :
{
}
{
    name() {
        return new DatabaseName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

TableName tableName() :
{
}
{
    name() {
        return new TableName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

ColumnName columnName() :
{
}
{
    name() {
        return new ColumnName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

IndexName indexName() :
{
}
{
    name() {
        return new IndexName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

CollationName collationName() :
{
}
{
    name() {
        return new CollationName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

ConstraintName constraintName() :
{
}
{
    name() {
        return new ConstraintName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

ColumnAlias columnAlias() :
{
}
{
    name() {
        return new ColumnAlias(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

TableAlias tableAlias() :
{
}
{
    name() {
        return new TableAlias(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

FunctionName functionName() :
{
}
{
    name() {
        return new FunctionName(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}