options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
    COMMON_TOKEN_ACTION = true;
    IGNORE_CASE = true;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;

import main.sqlipa.ast.*;
import main.sqlipa.ast.constraint.*;
import main.sqlipa.ast.constraint.table.*;
import main.sqlipa.ast.constraint.column.*;
import main.sqlipa.ast.expr.*;
import main.sqlipa.ast.literal.*;
import main.sqlipa.ast.stmt.*;
import main.sqlipa.ast.stmt.alter.*;
import main.sqlipa.ast.stmt.create.*;
import main.sqlipa.ast.stmt.drop.*;
import main.sqlipa.ast.stmt.event.*;
import main.sqlipa.ast.stmt.event.delete.*;
import main.sqlipa.ast.stmt.event.insert.*;
import main.sqlipa.ast.stmt.event.select.*;
import main.sqlipa.ast.stmt.event.update.*;
import main.sqlipa.ast.stmt.pragma.*;

public final class ASTParser {
}

PARSER_END(ASTParser)

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\f"
|   "\r"
}

/* Comments */
SPECIAL_TOKEN :
{
    <LINE_COMMENT: "--" (~["\n"])* "\n">
}

MORE :
{
    "/*": IN_BLOCK_COMMENT
}

<IN_BLOCK_COMMENT> MORE :
{
    <~[]>
}

<IN_BLOCK_COMMENT> SPECIAL_TOKEN :
{
    <BLOCK_COMMENT: "*/">: DEFAULT
}

TOKEN_MGR_DECLS :
{
    // TODO: correct comments.
    private List<Comment> comments = new ArrayList<Comment>();
    
    private void CommonTokenAction(Token token) {
        token = token.specialToken;
        while (token != null) {
            if (token.kind == LINE_COMMENT) {
                comments.add(new LineComment(new Block(token.beginLine, token.beginColumn,
                    token.endLine, token.endColumn), token.image));
            } else if (token.kind == BLOCK_COMMENT) {
                comments.add(new BlockComment(new Block(token.beginLine, token.beginColumn,
                    token.endLine, token.endColumn), token.image));
            } else {
                break;
            }
            token = token.specialToken;
        }
    }
    
    public List<Comment> popComments() {
        List<Comment> ret = comments;
        comments = new ArrayList<Comment>();
        return ret;
    }
    
    public List<Comment> peekComments() {
        return comments;
    }
}

/* Keywords */
TOKEN :
{
    <ABORT: "ABORT">
|   <ACTION: "ACTION">
|   <ADD: "ADD">
|   <AFTER: "AFTER">
|   <ALL: "ALL">
|   <ALTER: "ALTER">
|   <ANALYZE: "ANALYZE">
|   <AND: "AND">
|   <AS: "AS">
|   <ASC: "ASC">
|   <ATTACH: "ATTACH">
|   <AUTOINCREMENT: "AUTOINCREMENT">
|   <BEFORE: "BEFORE">
|   <BEGIN: "BEGIN">
|   <BETWEEN: "BETWEEN">
|   <BY: "BY">
|   <CASCADE: "CASCADE">
|   <CASE: "CASE">
|   <CAST: "CAST">
|   <CHECK: "CHECK">
|   <COLLATE: "COLLATE">
|   <COLUMN: "COLUMN">
|   <COMMIT: "COMMIT">
|   <CONFLICT: "CONFLICT">
|   <CONSTRAINT: "CONSTRAINT">
|   <CREATE: "CREATE">
|   <CROSS: "CROSS">
|   <CURRENT_DATE: "CURRENT_DATE">
|   <CURRENT_TIME: "CURRENT_TIME">
|   <CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <DATABASE: "DATABASE">
|   <DEFAULT_: "DEFAULT">
|   <DEFERRABLE: "DEFERRABLE">
|   <DEFERRED: "DEFERRED">
|   <DELETE: "DELETE">
|   <DESC: "DESC">
|   <DETACH: "DETACH">
|   <DISTINCT: "DISTINCT">
|   <DROP: "DROP">
|   <EACH: "EACH">
|   <ELSE: "ELSE">
|   <END: "END">
|   <ESCAPE: "ESCAPE">
|   <EXCEPT: "EXCEPT">
|   <EXCLUSIVE: "EXCLUSIVE">
|   <EXISTS: "EXISTS">
|   <EXPLAIN: "EXPLAIN">
|   <FAIL: "FAIL">
|   <FOR: "FOR">
|   <FOREIGN: "FOREIGN">
|   <FROM: "FROM">
|   <FULL: "FULL">
|   <GLOB: "GLOB">
|   <GROUP: "GROUP">
|   <HAVING: "HAVING">
|   <IF: "IF">
|   <IGNORE: "IGNORE">
|   <IMMEDIATE: "IMMEDIATE">
|   <IN: "IN">
|   <INDEX: "INDEX">
|   <INDEXED: "INDEXED">
|   <INITIALLY: "INITIALLY">
|   <INNER: "INNER">
|   <INSERT: "INSERT">
|   <INSTEAD: "INSTEAD">
|   <INTERSECT: "INTERSECT">
|   <INTO: "INTO">
|   <IS: "IS">
|   <ISNULL: "ISNULL">
|   <JOIN: "JOIN">
|   <KEY: "KEY">
|   <LEFT: "LEFT">
|   <LIKE: "LIKE">
|   <LIMIT: "LIMIT">
|   <MATCH: "MATCH">
|   <NATURAL: "NATURAL">
|   <NO: "NO">
|   <NOT: "NOT">
|   <NOTNULL: "NOTNULL">
|   <NULL: "NULL">
|   <OF: "OF">
|   <OFFSET: "OFFSET">
|   <ON: "ON">
|   <OR: "OR">
|   <ORDER: "ORDER">
|   <OUTER: "OUTER">
|   <PLAN: "PLAN">
|   <PRAGMA: "PRAGMA">
|   <PRIMARY: "PRIMARY">
|   <QUERY: "QUERY">
|   <RAISE: "RAISE">
|   <REFERENCES: "REFERENCES">
|   <REGEXP: "REGEXP">
|   <REINDEX: "REINDEX">
|   <RELEASE: "RELEASE">
|   <RENAME: "RENAME">
|   <REPLACE: "REPLACE">
|   <RESTRICT: "RESTRICT">
|   <RIGHT: "RIGHT">
|   <ROLLBACK: "ROLLBACK">
|   <ROW: "ROW">
|   <SAVEPOINT: "SAVEPOINT">
|   <SELECT: "SELECT">
|   <SET: "SET">
|   <TABLE: "TABLE">
|   <TEMP: "TEMP">
|   <TEMPORARY: "TEMPORARY">
|   <THEN: "THEN">
|   <TO: "TO">
|   <TRANSACTION: "TRANSACTION">
|   <TRIGGER: "TRIGGER">
|   <UNION: "UNION">
|   <UNIQUE: "UNIQUE">
|   <UPDATE: "UPDATE">
|   <USING: "USING">
|   <VACUUM: "VACUUM">
|   <VALUES: "VALUES">
|   <VIEW: "VIEW">
|   <VIRTUAL: "VIRTUAL">
|   <WHEN: "WHEN">
|   <WHERE: "WHERE">
}

/* Operators */
TOKEN :
{
    <CONCATENATION: "||">
|   <STAR: "*">
|   <SLASH: "/">
|   <MODULO: "%">
|   <PLUS: "+">
|   <MINUS: "-">
|   <SHIFT_HIGH: "<<">
|   <SHIFT_LOW: ">>">
|   <BIT_AND: "&">
|   <BIT_OR: "|">
|   <BIT_NOT: "~">
|   <LESS: "<">
|   <LESS_OR_EQUAL: "<=">
|   <GREATER: ">">
|   <GREATER_OR_EQUAL: ">=">
|   <EQUAL_1: "=">
|   <EQUAL_2: "==">
|   <NOT_EQUAL_1: "!=">
|   <NOT_EQUAL_2: "<>">
}

/* Literals & Identifiers */
TOKEN :
{
    <NUMERIC:
        (
            (<DIGIT>)+ (<DOT> (<DIGIT>)*)?
        |   <DOT> (<DIGIT>)+
        )
        (<EXPONENT>)?
    >
|   <#EXPONENT: "E" (["+", "-"])? (<DIGIT>)+>
|   <STRING: "'" (~["'"])* ("''" (~["'"])*)* "'">
|   <BLOB: "X'" (<HEX_CHAR> <HEX_CHAR>)* "'">
|   <PARAMETER: 
        "?" (<DIGIT>)*
    |   (":" | "@" | "$") // sqlite implementation also allows '#'.
        ("::")?
        <CHAR>
        (<CHAR> | "::")*
        (
            "("
            (~[")", "\t", "\n", "\f", "\r", " "])*
            ")"
        )?
    >
|   <ID: 
        <CHAR> (<CHAR> | <DIGIT>)*
    |   "\"" (~["\""])* ("\"\"" (~["\""])*)* "\""
    |   "`" (~["`"])* ("``" (~["`"])*)* "`"
    |   "[" (~["]"])* "]"
    >
}

/* Separators */
TOKEN :
{
    <LP: "(">
|   <RP: ")">
|   <SEMICOLON: ";">
|   <COMMA: ",">
|   <DOT: ".">
}

/* Char Sets */
TOKEN :
{
    <#DIGIT: ["0" - "9"]>
    // Has mentioned in sqlite implementation '$' is not documented but is implemented for
    // compatibility.
|   <#CHAR: ["A" - "Z", "_", "$"]>
|   <#HEX_CHAR: ["0" - "9", "A" - "F"]>
}

/* Grammar */
SqlStmtList sqlStmtList() :{
    SqlStmtList stmtList = new SqlStmtList();
    SqlStatement stmt = null;
    
    stmtList.stmts =  new ArrayList<SqlStatement>();
}
{
    [
        (
            stmt = sqlStmt() {
                stmtList.stmts.add(stmt);
            }
        |   ";"
        ) {
            stmtList.setBegin(token.beginLine, token.beginColumn);
        }
        (
            ";"
            [
                stmt = sqlStmt() {
                    stmtList.stmts.add(stmt);
                }
            ]
        )*
    ] {
        if (stmt == null) {
            stmtList.setBegin(token.beginLine, token.beginColumn);
            stmtList.stmts = null;
        }
        stmtList.setEnd(token.endLine, token.endColumn);
        return stmtList;
    }
}

SqlStatement sqlStmt() :
{
    int line = 0;
    int column = 0;
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            line = token.beginLine;
            column = token.beginColumn;
            explain = SqlStatement.Explain.NORMAL;
        } 
        [ "QUERY" "PLAN" ] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    (
        stmt = alterTableStmt()
    |   stmt = analyzeStmt()
    |   stmt = attachStmt()
	|   stmt = beginStmt()
	|   stmt = commitStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createTableStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createTriggerStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createViewStmt()
	|   stmt = createVirtualTableStmt()	|   stmt = deleteStmt()
	|   stmt = detachStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
	    stmt = dropIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        stmt = dropTableStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        stmt = dropTriggerStmt()
	|   stmt = dropViewStmt()
	|   stmt = insertStmt()
	|   stmt = pragmaStmt()
	|   stmt = reindexStmt()
	|   stmt = releaseStmt()
	|   stmt = rollbackStmt()
	|   stmt = savepointStmt()
	|   stmt = selectStmt()
	|   stmt = updateStmt()
	|   stmt = vacuumStmt()
	) {
        if (explain != null) {
            // If statement starts by EXPLAIN.
            stmt.setBegin(line, column);
            stmt.explain = explain;
        }
        return stmt;
    }
}

Name name() :
{
}
{
    (
        <ID>
    |   <STRING>
    ) {
        return new Name(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

AlterTableStmt alterTableStmt() :
{
    AlterTableStmt stmt;
    int line;
    int column;
    Name database = null;
    Name table;
}
{
    "ALTER" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    "TABLE"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    (
        stmt = renameTableStmt()
    |   stmt = addColumnStmt()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.database = database;
        stmt.table = table;
        return stmt;
    }
}

AlterTableStmt renameTableStmt() :
{
    RenameTableStmt stmt = new RenameTableStmt();
}
{
    "RENAME" "TO"
    stmt.newTable = name() {
        return stmt;
    }
}

AlterTableStmt addColumnStmt() :
{
    AddColumnStmt stmt = new AddColumnStmt();
}
{
    "ADD"
    [
    	"COLUMN" {
    		stmt.hasColumn = true;    	}
	]
    stmt.column = columnDef() {
        return stmt;
    }
}

AnalyzeStmt analyzeStmt() :
{
    AnalyzeStmt stmt = new AnalyzeStmt();
}
{
    "ANALYZE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        stmt.first = name()
        [
            "."
            stmt.second = name()
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

AttachStmt attachStmt() :
{
    AttachStmt stmt = new AttachStmt();
}
{
    "ATTACH" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DATABASE" {
        	stmt.hasDatabase = true;        } 
    ]
    stmt.expr = expr()
    "AS"
    stmt.database = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

BeginStmt beginStmt() :
{
    BeginStmt stmt = new BeginStmt();
}
{
    "BEGIN" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DEFERRED" {
            stmt.type = BeginStmt.Type.DEFERRED;
        }
    |   "IMMEDIATE" {
            stmt.type = BeginStmt.Type.IMMEDIATE;
        }
    |   "EXCLUSIVE" {
            stmt.type = BeginStmt.Type.EXCLUSIVE;
        }
    ]
    [
        "TRANSACTION" {			stmt.hasTransaction = true;
        }
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CommitStmt commitStmt() :
{
    CommitStmt stmt = new CommitStmt();
}
{
    (
        "COMMIT" {
        	stmt.type = CommitStmt.Type.COMMIT;        }
    |   "END" {			stmt.type = CommitStmt.Type.END;
        }
    ) {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "TRANSACTION" {
        	stmt.hasTransaction = true;        }
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

RollbackStmt rollbackStmt() :
{
    RollbackStmt stmt = new RollbackStmt();
}
{
    "ROLLBACK"  {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
    	"TRANSACTION" {			stmt.hasTransaction = true;
		}
	]
    [
        "TO"
        [
        	"SAVEPOINT"	{				stmt.hasSavepoint = true;
        	}
        ]
        stmt.savepoint = name()
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SavepointStmt savepointStmt() :
{
    SavepointStmt stmt = new SavepointStmt();
}
{
    "SAVEPOINT"  {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    stmt.savepoint = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

ReleaseStmt releaseStmt() :
{
    ReleaseStmt stmt = new ReleaseStmt();
}
{
    "RELEASE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
    	"SAVEPOINT"	{			stmt.hasSavepoint = true;
    	}
	]
    stmt.savepoint = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CreateIndexStmt createIndexStmt() :
{
    CreateIndexStmt stmt = new CreateIndexStmt();
    IndexedColumn column;
    
    stmt.columns = new ArrayList<IndexedColumn>();
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "UNIQUE" { 
            stmt.hasUnique = true;
        }
    ]
    "INDEX"
    [
        "IF" "NOT" "EXISTS" { 
            stmt.hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name()
    "ON"
    stmt.table = name()
    "("
    column = indexedColumn() {
        stmt.columns.add(column);
    }
    (
        ","
	    column = indexedColumn() {
	        stmt.columns.add(column);
	    }
    )*
    ")" {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

IndexedColumn indexedColumn() :
{
    IndexedColumn column = new IndexedColumn();
}
{
    column.column = name() {
        column.setBegin(column.column);
    }
    [
        "COLLATE"
        column.collation = name()
    ]
    [
        "ASC" {
            column.order = IndexedColumn.Order.ASC;
        }
    |   "DESC" {
            column.order = IndexedColumn.Order.DESC;
        }
    ] {
        column.setEnd(token.endLine, token.endColumn);
        return column;
    }}

CreateTableStmt createTableStmt() :
{
    CreateTableStmt stmt;
    int line;
    int column;
    boolean hasTemporary = false;
    boolean hasIfNotExists = false;
    Name database = null;
    Name table;
}
{
    "CREATE" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemporary = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.hasTemporary = hasTemporary;
        stmt.hasIfNotExists = hasIfNotExists;
        stmt.name = table;
        stmt.database = database;
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
    
    stmt.columns = new ArrayList<ColumnDef>();
}
{
    "("
    column = columnDef() { 
        stmt.columns.add(column);
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHEAD(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        ","
        column = columnDef() {
            stmt.columns.add(column);
        }
    )* 
    (   
        "," {
            if (stmt.constraints == null) {
                stmt.constraints = new ArrayList<TableConstraint>();
            }
            TableConstraint constraint;
        }
        constraint = tableConstraint() { 
            stmt.constraints.add(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmt createTableStmtWithSelect() :
{
    CreateTableStmtWithSelect stmt = new CreateTableStmtWithSelect();
}
{
    "AS"
    stmt.select = selectStmt() {
        return stmt;
    }
}

ColumnDef columnDef() :
{
    ColumnDef column = new ColumnDef();
    ColumnConstraint constraint = null;
    
    column.constraints = new ArrayList<ColumnConstraint>();}
{
    column.column = name() {
        column.setBegin(column.column);
    }
    [
        column.type = typeName()
    ]
    (
        constraint = columnConstraint() {
            column.constraints.add(constraint);
        }
    )* {
        column.setEnd(token.endLine, token.endColumn);
        if (constraint == null) {
            column.constraints = null;
        }
        return column;
    }}

TypeName typeName() :
{
    TypeName type = new TypeName();
    type.name = new String();
}
{
    name() {
        type.setBegin(token.beginLine, token.beginColumn);
        type.name += token.image;
    }
    (
        name() {
            type.name += " " + token.image;
        }
    )*
    [
        "("
        type.xDimension = signedNumber()
        [
            ","
            type.yDimension = signedNumber()
        ]
        ")"
    ] {
        type.setEnd(token.endLine, token.endColumn);
        return type;
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    int line = 0;
    int column = 0;
    Name name = null;}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = name()
    ]
    (
        constraint = primaryKeyColumnConstraint()
    |   constraint = notNullColumnConstraint()
    |   constraint = uniqueColumnConstraint()
    |   constraint = checkColumnConstraint()
    |   constraint = defaultColumnConstraint()    |   constraint = collateColumnConstraint()
    |   constraint = foreignKeyColumnConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.name = name;
        }
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint() :
{
    PrimaryKeyColumnConstraint constraint = new PrimaryKeyColumnConstraint();
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        "ASC" {
            constraint.order = PrimaryKeyColumnConstraint.Order.ASC;
        }
    |   "DESC" {
            constraint.order = PrimaryKeyColumnConstraint.Order.DESC;
        }
    ]
    constraint.clause = conflictClause()
    [
        "AUTOINCREMENT" {
            constraint.hasAutoincrement = true;
        }
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

NotNullColumnConstraint notNullColumnConstraint() :
{
    NotNullColumnConstraint constraint = new NotNullColumnConstraint();
}
{
    "NOT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    constraint.clause = conflictClause() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueColumnConstraint uniqueColumnConstraint() :
{
    UniqueColumnConstraint constraint = new UniqueColumnConstraint();
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    constraint.clause = conflictClause() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckColumnConstraint checkColumnConstraint() :
{
    CheckColumnConstraint constraint = new CheckColumnConstraint();
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    constraint.expr = expr()
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

DefaultColumnConstraint defaultColumnConstraint() :
{
    DefaultColumnConstraint constraint = new DefaultColumnConstraint();
    Literal literal;
}
{
    "DEFAULT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    (
        // As signedNumber and literalValue match a numericLiteral() it is only
        // consider to exist a signedNumber if actually there is sign.
        LOOKAHEAD("+" | "-")
        constraint.expr = signedNumber()
    |   literal = literalValue() {
            constraint.expr = new LiteralExpr(literal, literal);
        }
    |   "("
        constraint.expr = expr()
        ")"
    ) {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CollateColumnConstraint collateColumnConstraint() :
{
    CollateColumnConstraint constraint = new CollateColumnConstraint();
}
{
    "COLLATE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    constraint.collation = name() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint() :
{
    ForeignKeyColumnConstraint constraint = new ForeignKeyColumnConstraint();
}
{
    constraint.clause = foreignKeyClause() {
        return constraint;
    }
}

UnaryExpr signedNumber() :
{
    UnaryExpr number = new UnaryExpr();
    NumericLiteral literal;}
{
    [
        (
            "+" {
                number.operator = UnaryExpr.Operator.POSITIVE;
            }
        |   "-" {
                number.operator = UnaryExpr.Operator.NEGATIVE;
            }
        ) {
            number.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        if (number.operator == null) {
            number.setBeginEnd(literal);
        } else {
            number.setEnd(token.endLine, token.endColumn);
        }
        number.expr = new LiteralExpr(literal, literal);
        return number;
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    int line = 0;
    int column = 0;
    Name name = null;
}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = name()
    ]
    (
        constraint = primaryKeyTableConstraint()
    |   constraint = checkTableConstraint()
    |   constraint = foreignKeyTableConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.name = name;
        }
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint() :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    
    constraint.columns = new ArrayList<IndexedColumn>();
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.columns.add(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.columns.add(column);
        }
    )*
    ")"
    constraint.clause = conflictClause() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint() :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    
    constraint.columns = new ArrayList<IndexedColumn>();
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.columns.add(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.columns.add(column);
        }
    )*
    ")"
    constraint.clause = conflictClause() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint() :
{
    CheckTableConstraint constraint = new CheckTableConstraint();
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    constraint.expr = expr() 
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint() :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    Name column;
    
    constraint.columns = new ArrayList<Name>();
}
{
    "FOREIGN" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = name() {
        constraint.columns.add(column);
    }
    (
        "," 
        column = name() {
            constraint.columns.add(column);
        }
    )*
    ")"
    constraint.clause = foreignKeyClause() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{
    ForeignKeyClause clause = new ForeignKeyClause();
    ForeignKeySetting setting = null;
    
    clause.settings = new ArrayList<ForeignKeySetting>();}
{
    "REFERENCES" {
        clause.setBegin(token.beginLine, token.beginColumn);
    }
    clause.table = name()
    [
        "(" {
            Name column;
            clause.columns = new ArrayList<Name>();
        }
        column = name() {
            clause.columns.add(column);
        }
        (
            ","
            column = name() {
                clause.columns.add(column);
            }
        )*
        ")"
    ]
    (
        setting = onSetting() {
            clause.settings.add(setting);
        }
    |   setting = matchSetting() {
            clause.settings.add(setting);
        }
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
        setting = deferrableSetting() {
            clause.settings.add(setting);
        }
    ] {
        if (setting == null) {
            clause.settings = null;
        }
        clause.setEnd(token.endLine, token.endColumn);
        return clause;
    }}

OnSetting onSetting() :
{
    OnSetting sett = new OnSetting();
}
{
    "ON" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    (
        "DELETE" {
            sett.event = OnSetting.Event.DELETE;
        }
    |   "UPDATE" {
            sett.event = OnSetting.Event.UPDATE;
        }
    )
    (
        "SET"
        (
            "NULL" {
                sett.action = OnSetting.Action.SET_NULL;
            }
        |   "DEFAULT" {
                sett.action = OnSetting.Action.SET_DEFAULT;
            }
        )
    |   "CASCADE" {
            sett.action = OnSetting.Action.CASCADE;
        }
    |   "RESTRICT" {
            sett.action = OnSetting.Action.RESTRICT;
        }
    |   "NO" "ACTION" {
            sett.action = OnSetting.Action.NO_ACTION;
        }
    ) {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

MatchSetting matchSetting() :
{
    MatchSetting sett = new MatchSetting();
}
{
    "MATCH" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    name() {
        sett.name = new Name(new Block(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn), token.image);
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

DeferrableSetting deferrableSetting() :
{
    DeferrableSetting sett = new DeferrableSetting();
}
{
    (
        "NOT" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.type = DeferrableSetting.Type.NOT_DEFERRABLE;
        }
        "DEFERRABLE"
    |   "DEFERRABLE" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.type = DeferrableSetting.Type.DEFERRABLE;
        }
    )
    [
        "INITIALLY"
        (
            "DEFERRED" {
                sett.mode = DeferrableSetting.Mode.DEFERRED;
            }
        |   "IMMEDIATE" {
                sett.mode = DeferrableSetting.Mode.IMMEDIATE;
            }
        )
    ] {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

ConflictClause conflictClause() :
{
}
{
    [   
        "ON" {
            ConflictClause clause = new ConflictClause();
            clause.setBegin(token.beginLine, token.beginColumn);
        }
        "CONFLICT"
        (
            "ROLLBACK" {
                clause.action = ConflictClause.Action.ROLLBACK;
            }
        |   "ABORT" {
                clause.action = ConflictClause.Action.ABORT;
            }
        |   "FAIL" {
                clause.action = ConflictClause.Action.FAIL;
            }
        |   "IGNORE" {
                clause.action = ConflictClause.Action.IGNORE;
            }
        |   "REPLACE" {
                clause.action = ConflictClause.Action.REPLACE;
            }
        ) {
            clause.setEnd(token.endLine, token.endColumn);
            return clause;
        }
    ] {
        return null;
    }}

CreateTriggerStmt createTriggerStmt() :
{
    CreateTriggerStmt stmt = new CreateTriggerStmt();
    stmt.stmts = new ArrayList<EventStmt>();
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        ("TEMP" | "TEMPORARY") {
            stmt.hasTemporary = true;
        }
    ]
    "TRIGGER"
    [
        "IF" "NOT" "EXISTS" {
            stmt.hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name()
    [
        "BEFORE" {
            stmt.time = CreateTriggerStmt.Time.BEFORE;
        }
    |   "AFTER" {
            stmt.time = CreateTriggerStmt.Time.AFTER;
        }
    |   "INSTEAD" "OF" {
            stmt.time = CreateTriggerStmt.Time.INSTEAD_OF;
        }
    ]
    (
        "DELETE" {
            stmt.event = CreateTriggerStmt.Event.DELETE;
        }
    |   "INSERT"  {
            stmt.event = CreateTriggerStmt.Event.INSERT;
        }
    |   "UPDATE" {
            stmt.event = CreateTriggerStmt.Event.UPDATE;
        }
        [
            "OF" {
                Name column;
                stmt.columns = new ArrayList<Name>();
            }
            column = name() {
                stmt.columns.add(column);
            }
            (
                ","
                column = name() {
                    stmt.columns.add(column);
                }
            )*
        ]
    )
    "ON"
    stmt.table = name()
    [
        "FOR" "EACH" "ROW" {
            stmt.hasForEachRow = true;
        }
    ]
    [
        "WHEN"
        stmt.when = expr()
    ]
    "BEGIN" {
        EventStmt eventStmt;
    }
    (
        (
            eventStmt = updateStmt()
        |   eventStmt = insertStmt()
        |   eventStmt = deleteStmt()
        |   eventStmt = selectStmt()
        ) {
            stmt.stmts.add(eventStmt);
        }
        ";"
    )+
    "END" {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CreateViewStmt createViewStmt() :
{
    CreateViewStmt stmt = new CreateViewStmt();
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        ("TEMP" | "TEMPORARY") {
            stmt.hasTemporary = true;
        }
    ]
    "VIEW"
    [
        "IF" "NOT" "EXISTS" {
            stmt.hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name()
    "AS"
    stmt.select = selectStmt() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CreateVirtualTableStmt createVirtualTableStmt() :
{
    CreateVirtualTableStmt stmt = new CreateVirtualTableStmt();
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "VIRTUAL" "TABLE"
    [
        "IF" "NOT" "EXISTS" {
            stmt.hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name()
    "USING"
    stmt.module = name()
    [
        "(" {
            ModuleArgument argument;
            stmt.arguments = new ArrayList<ModuleArgument>();
        }
        argument = moduleArgument() {
            stmt.arguments.add(argument);
        }
        (
            ","
            argument = moduleArgument() {
                stmt.arguments.add(argument);
            }
        )*
        ")"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

ModuleArgument moduleArgument() :
{
}
{
    // TODO:
    [
	    "("
        other()
	    ")"
    ] {
        return new ModuleArgument(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

void other() :
{
}
{
    [
	    "("
        other()
	    ")"
    ]
}

DeleteStmt deleteStmt() :
{
    DeleteStmt stmt = new DeleteStmt();
}
{
    "DELETE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "FROM"
    stmt.qualifiedTable = qualifiedTableName()
    [
        "WHERE"
        stmt.where = expr()
    ]
    stmt.constraint = eventConstraint() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

EventConstraint eventConstraint() :
{
    EventConstraint constraint = new EventConstraint();
}
{
    [
        "ORDER" {
            constraint.setBegin(token.beginLine, token.beginColumn);
            OrderingTerm term;
            
            constraint.terms = new ArrayList<OrderingTerm>();
        }
        "BY"
        term = orderingTerm() {
            constraint.terms.add(term);
        }
        (
            ","
            term = orderingTerm() {
                constraint.terms.add(term);
            }
        )*
    ]
    [
        "LIMIT" {
            if (constraint.terms == null) {
                constraint.setBegin(token.beginLine, token.beginColumn);
            }
        }
        constraint.limit = expr()
        [
            ( "OFFSET" | "," )
            constraint.offset = expr()
        ]
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        if (constraint.terms == null && constraint.limit == null) {
            return null;
        }
        return constraint;
    }
}

DetachStmt detachStmt() :
{
    DetachStmt stmt = new DetachStmt();
}
{
    "DETACH" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
    	"DATABASE" {
    		stmt.hasDatabase = true;    	}
    ]
    stmt.database = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

DropIndexStmt dropIndexStmt() :
{
    DropIndexStmt stmt = new DropIndexStmt();
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "INDEX"
    [
        "IF" "EXISTS" {
            stmt.hasIfExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

DropTableStmt dropTableStmt() :
{
    DropTableStmt stmt = new DropTableStmt();
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "TABLE"
    [
        "IF" "EXISTS" {
            stmt.hasIfExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

DropTriggerStmt dropTriggerStmt() :
{
    DropTriggerStmt stmt = new DropTriggerStmt();
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "TRIGGER"
    [
        "IF" "EXISTS" {
            stmt.hasIfExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

DropViewStmt dropViewStmt() :
{
    DropViewStmt stmt = new DropViewStmt();
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "VIEW"
    [
        "IF" "EXISTS" {
            stmt.hasIfExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.name = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

// Expression is built by parts recursively to ensure operator precedences are
// to avoid left recursion.
Expression expr() :
{
    Expression left;
    Expression right;
}
{
    left = andExpr()   
    (
        "OR"
        right = andExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, BinaryExpr.Operator.OR);
        }
    )* {
        return left;
    }
}

Expression andExpr() :
{
    Expression left;
    Expression right;
}
{
    left = notExpr()
    (
        "AND"
        right = notExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, BinaryExpr.Operator.AND);
        }
    )* {
        return left;
    }
}

Expression notExpr() :
{
    Expression expr;
}
{
    (
        "NOT" {
            int line = token.beginLine;
            int column = token.beginColumn;
        }
        expr = notExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine, token.endColumn),
                UnaryExpr.Operator.LOGICAL_NOT, expr);
        }
    |   expr = equalityExpr() 
    ) {
        return expr;
    }
}

Expression equalityExpr() :
{
    Expression expr;
}
{
    expr = relationalExpr()
    // All types of expressions in this choice point can start by "NOT". 
    // LOOKAHEAD removes ambiguity which one to choose.
    (
        LOOKAHEAD(2)
        expr = unaryEqualityExpr(expr)
    |   LOOKAHEAD(2)
        expr = betweenExpr(expr)
    |   LOOKAHEAD(2)
        expr = inExpr(expr)
    |   expr = binaryEqualityExpr(expr)
    )* {
        return expr;
    }
}

Expression unaryEqualityExpr(Expression expr) :
{
    UnaryExpr.Operator operator;
}
{
    (
        "ISNULL" {
            operator = UnaryExpr.Operator.IS_NULL;
        }
    |   "NOTNULL" {
            operator = UnaryExpr.Operator.NOT_NULL;
        }
    |   "NOT" "NULL" {
            operator = UnaryExpr.Operator.NOT_NULL;
        }
    ) {
        return new UnaryExpr(new Block(expr.beginLine, expr.beginColumn, token.endLine,
            token.endColumn), operator, expr);
    }
}

Expression binaryEqualityExpr(Expression left) :
{
    Expression right;
    BinaryExpr.Operator operator;
}
{
    operator = binaryEqualityOperator()
    right = relationalExpr() {
        return new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
            token.endColumn), left, right, operator);
    }
}

BinaryExpr.Operator binaryEqualityOperator() :
{
}
{
    "=" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "==" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "!=" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "<>" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "IS"
    [
        "NOT" {
            return BinaryExpr.Operator.IS_NOT;
        }
    ] {
        return BinaryExpr.Operator.IS;
    }
|   "NOT"
    (
        "LIKE" {
            return BinaryExpr.Operator.NOT_LIKE;
        }
    |   "GLOB" {
            return BinaryExpr.Operator.NOT_GLOB;
        }
    |   "REGEXP" {
            return BinaryExpr.Operator.NOT_REGEXP;
        }
    |   "MATCH" {
            return BinaryExpr.Operator.NOT_MATCH;
        }
    )
|   "LIKE" {
        return BinaryExpr.Operator.LIKE;
    }
|   "GLOB" {
        return BinaryExpr.Operator.GLOB;
    }
|   "REGEXP" {
        return BinaryExpr.Operator.REGEXP;
    }
|   "MATCH" {
        return BinaryExpr.Operator.MATCH;
    }
}

BetweenExpr betweenExpr(Expression expr) :
{
    BetweenExpr between = new BetweenExpr();
    
    between.expr = expr;
    between.setBegin(expr);
}
{
    (
        "NOT" "BETWEEN" {
            between.operator = BetweenExpr.Operator.NOT_BETWEEN;
        }
    |   "BETWEEN" {
            between.operator = BetweenExpr.Operator.BETWEEN;
        }
    )
    between.lower = relationalExpr()
    "AND"
    between.upper = relationalExpr() {
        between.setEnd(token.endLine, token.endColumn);
        return between;
    }
}

InExpr inExpr(Expression expr) :
{
    InExpr in = null;
    InExpr.Operator operator;
}
{
    (
        "NOT" "IN" {
            operator = InExpr.Operator.NOT_IN;
        }
    |   "IN" {
            operator = InExpr.Operator.IN;
        }
    )
    (
        "("
        (
            in = inSelectExpr()
        |   in = inSetExpr()
        )
        ")"
    |   in = inTableExpr()
    ) {
        in.expr = expr;
        in.operator = operator;
        in.setBegin(expr);
        in.setEnd(token.endLine, token.endColumn);
        return in;
    }
}

InSelectExpr inSelectExpr() :
{
    InSelectExpr in = new InSelectExpr();
}
{
    in.select = selectStmt() {
        return in;
    }
}

InSetExpr inSetExpr() :
{
    InSetExpr in = new InSetExpr();
    Expression expr;
}
{
    [
	    expr = expr() {
	        in.set = new ArrayList<Expression>();
	        in.set.add(expr);
	    }
	    (
	        ","
	        expr = expr() {
	            in.set.add(expr);
	        }
	    )*
    ] {
        return in;
    }
}

InTableExpr inTableExpr() :
{
    InTableExpr in = new InTableExpr();
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        in.database = name()
        "."
    ]
    in.table = name() {
        return in;
    }
}

Expression relationalExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator operator;
}
{
    left = escapeExpr()
    (
        (
            "<" {
                operator = BinaryExpr.Operator.LESS;
            }
        |   "<=" {
                operator = BinaryExpr.Operator.LESS_OR_EQUAL;
            }
        |   ">" {
                operator = BinaryExpr.Operator.GREATER;
            }
        |   ">=" {
                operator = BinaryExpr.Operator.GREATER_OR_EQUAL;
            }
        )
        right = escapeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, operator);
        }
    )* {
        return left;
    }
}

Expression escapeExpr() :
{
    Expression left;
    Expression right;
}
{
    left = bitwiseExpr()
    [
        "ESCAPE"
        right = bitwiseExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, BinaryExpr.Operator.ESCAPE);
        }
    ] {
        return left;
    }
}

Expression bitwiseExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator operator;
}
{
    left = additiveExpr()
    (
        operator = bitwiseOperator()
        right = additiveExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, operator);
        }
    )* {
        return left;
    }
}

BinaryExpr.Operator bitwiseOperator() :
{
}
{
    ">>" {
        return BinaryExpr.Operator.SHIFT_HIGH;
    }
|   "<<" {
        return BinaryExpr.Operator.SHIFT_LOW;
    }
|   "&" {
        return BinaryExpr.Operator.BIT_AND;
    }
|   "|" {
        return BinaryExpr.Operator.BIT_OR;
    }
}

Expression additiveExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator operator;
}
{
    left = multiplicativeExpr()
    (
        (
            "+" {
                operator = BinaryExpr.Operator.ADDITION;
            }
        |   "-" {
                operator = BinaryExpr.Operator.SUBTRACTION;
            }
        )
        right = multiplicativeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, operator);
        }
    )* {
        return left;
    }
}

Expression multiplicativeExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator operator;
}
{
    left = concatenateExpr()
    (
        (
            "*" {
                operator = BinaryExpr.Operator.MULTIPLICATION;
            }
        |   "/" {
                operator = BinaryExpr.Operator.DIVISION;
            }
        |   "%" {
                operator = BinaryExpr.Operator.MODULO;
            }
        )
        right = concatenateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, operator);
        }
    )* {
        return left;
    }
}

Expression concatenateExpr() :
{
    Expression left;
    Expression right;
}
{
    left = collateExpr()
    (
        "||"
        right = collateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn, token.endLine,
                token.endColumn), left, right, BinaryExpr.Operator.CONCATENATION);
        }
    )* {
        return left;
    }
}

Expression collateExpr() :
{
    Expression expr;
    Name collation;
}
{
    expr = unaryExpr()
    (
        "COLLATE"
        collation = name() {
            expr = new CollateExpr(new Block(expr.beginLine, expr.beginColumn, token.endLine,
                token.endColumn), expr, collation);
        }
    )* {
        return expr;
    }
}

Expression unaryExpr() :
{
    Expression expr;
    UnaryExpr.Operator operator;
}
{
    (   
	    operator = unaryOperator() {
	        int line = token.beginLine;
	        int column = token.beginColumn;
	    }
        expr = unaryExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine, token.endColumn), operator,
                expr);
        }
    |   expr = terminalExpr()
    ) {
        return expr;
    }
}

UnaryExpr.Operator unaryOperator() :
{
}
{
    "-" {
        return UnaryExpr.Operator.NEGATIVE;
    }
|   "+" {
        return UnaryExpr.Operator.POSITIVE;
    }
|   "~" {
        return UnaryExpr.Operator.BIT_NOT;
    }
}

Expression terminalExpr() :
{
    Expression expr;
}
{
    (
        expr = bindParameterExpr()
    |   LOOKAHEAD(2) // columnExpr also starts with a name.
        expr = functionExpr()
    |   LOOKAHEAD(2) // literalExpr may also start with a <STRING>.
        expr = columnExpr()
    |   expr = literalExpr()
    |   expr = castExpr()
    |   expr = existsExpr()
    |   LOOKAHEAD(2) // selectExpr also starts by "(".
        "(" expr = expr() ")"
    |   expr = selectExpr()
    |   expr = caseExpr()
    |   expr = raiseFunctionExpr()
    ) {
        return expr;
    }
}

LiteralExpr literalExpr() :
{
    Literal literal;
}
{
    literal = literalValue() {
        return new LiteralExpr(new Block(literal), literal);
    }
}

BindParameterExpr bindParameterExpr() :
{
}
{
    <PARAMETER> {
        return new BindParameterExpr(new Block(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn), token.image);
    }
}

FunctionExpr functionExpr() :
{
    FunctionExpr function = new FunctionExpr();
    Expression expr;
}
{
    function.function = name() {
        function.setBegin(function.function);
    }
    "("
    [
        "*" {
            function.operator = FunctionExpr.Operator.UNIVERSAL;
        }
    |   [
            "DISTINCT" {
                function.operator = FunctionExpr.Operator.DISTINCT;
            }
        ]
        expr = expr() {
            function.exprs = new ArrayList<Expression>();
            function.exprs.add(expr);
        }
        (
            ","
            expr = expr() {
                function.exprs.add(expr);
            }
        )*
    ]
    ")" {
        function.setEnd(token.endLine, token.endColumn);
        return function;
    }
}

ColumnExpr columnExpr() :
{
    ColumnExpr reference = new ColumnExpr();
}
{
    (
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        [
            LOOKAHEAD(4) // Anticipate the occurrence of a dot.
            reference.database = name() {
                reference.setBegin(reference.database);
            }
            "."
        ]
        reference.table = name() {
            if (reference.database == null) {
                reference.setBegin(reference.table);
            }
        }
        "."    
	    reference.column = name() {
	        return reference;
	    }
    |   <ID> {
            // In case ColumnExpr only has the column name, that can't be a
            // <STRING> because would exist a syntactic conflict with a string
            // literal.
            reference.column = new Name(new Block(token.beginLine, token.beginColumn, token.endLine,
                token.endColumn), token.image);
        }
    ) {
        reference.setEnd(token.endLine, token.endColumn);
        return reference;
    }
}

CastExpr castExpr() :
{
    CastExpr cast = new CastExpr();
}
{
    "CAST" {
        cast.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    cast.expr = expr()
    "AS"
    cast.type = typeName()
    ")" {
        cast.setEnd(token.endLine, token.endColumn);
        return cast;
    }
}

UnaryExpr existsExpr() :
{
    UnaryExpr exists = new UnaryExpr();
}
{
    "EXISTS" {
        exists.setBegin(token.beginLine, token.beginColumn);
    }
    exists.expr = selectExpr() {
        exists.operator = UnaryExpr.Operator.EXISTS;
        exists.setEnd(token.endLine, token.endColumn);
        return exists;
    }
}

SelectExpr selectExpr() :
{
    SelectExpr expr = new SelectExpr();
}
{
    "(" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    expr.select = selectStmt()
    ")" {
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

CaseExpr caseExpr() :
{
    CaseExpr caseExpr = new CaseExpr();
    WhenExpr expr;
    
    caseExpr.whens = new ArrayList<WhenExpr>();
}
{
    "CASE" {
        caseExpr.setBegin(token.beginLine, token.beginColumn);
    }
    [
        caseExpr.caseExpr = expr()
    ]
    (
        expr = whenExpr() {
            caseExpr.whens.add(expr);
        }
    )+
    [
        "ELSE"
        caseExpr.elseExpr = expr()
    ]
    "END" {
        caseExpr.setEnd(token.endLine, token.endColumn);
        return caseExpr;
    }
}

WhenExpr whenExpr() :
{
    WhenExpr when = new WhenExpr();
}
{
    "WHEN" {
        when.setBegin(token.beginLine, token.beginColumn);
    }
    when.when = expr()
    "THEN"
    when.then = expr() {
        when.setEnd(token.endLine, token.endColumn);
        return when;
    }
}

RaiseFunctionExpr raiseFunctionExpr() :
{
    RaiseFunctionExpr expr = new RaiseFunctionExpr();
}
{
    "RAISE" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    (
        "IGNORE" {
            expr.type = RaiseFunctionExpr.Type.IGNORE;
        }
    |   (
            "ROLLBACK" {
                expr.type = RaiseFunctionExpr.Type.ROLLBACK;
            }
        |   "ABORT" {
                expr.type = RaiseFunctionExpr.Type.ABORT;
            }
        |   "FAIL" {
                expr.type = RaiseFunctionExpr.Type.FAIL;
            }
        )
        ","
        (
            <ID>
        |   <STRING>
        ) {
            expr.error = token.image;
        }
    )
    ")" {
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

Literal literalValue() :
{
    Literal literal;
}
{
    (
        literal = numericLiteral()
    |   literal = stringLiteral()
    |   literal = blobLiteral()
    |   (
            "NULL"
        |   "CURRENT_TIME"
        |   "CURRENT_DATE"
        |   "CURRENT_TIMESTAMP"
        ) {
            literal = new Literal(new Block(token.beginLine, token.beginColumn, token.endLine,
                token.endColumn), token.image);
        }
    ) {
        return literal;
    }
}

NumericLiteral numericLiteral() :
{
}
{
    <NUMERIC> {
        return new NumericLiteral(new Block(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn), token.image);
    }
}

StringLiteral stringLiteral() :
{
}
{
    <STRING> {
        return new StringLiteral(new Block(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn), token.image);
    }
}

BlobLiteral blobLiteral() :
{
}
{
    <BLOB> {
        return new BlobLiteral(new Block(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn), token.image);
    }
}

InsertStmt insertStmt() :
{
    InsertStmt stmt = new InsertStmtDefault();
    List<Name> columns = null;
}
{
    (
        "INSERT" {
            stmt.setBegin(token.beginLine, token.beginColumn);
            stmt.type = InsertStmt.Type.INSERT;
        }
        [
            "OR"
            (
                "ROLLBACK" {
                    stmt.type = InsertStmt.Type.INSERT_OR_ROLLBACK;
                }
            |   "ABORT" {
                    stmt.type = InsertStmt.Type.INSERT_OR_ABORT;
                }
            |   "REPLACE" {
                    stmt.type = InsertStmt.Type.INSERT_OR_REPLACE;
                }
            |   "FAIL" {
                    stmt.type = InsertStmt.Type.INSERT_OR_FAIL;
                }
            |   "IGNORE" {
                    stmt.type = InsertStmt.Type.INSERT_OR_IGNORE;
                }
            )
        ]
    |   "REPLACE" {
            stmt.setBegin(token.beginLine, token.beginColumn);
            stmt.type = InsertStmt.Type.REPLACE;
        }
    )
    "INTO"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.table = name()
    (
        "DEFAULT" "VALUES"
    |   [
            "(" {
                Name column;
                columns = new ArrayList<Name>();
            }
            column = name() {
                columns.add(column);
            }
            (
                ","
	            column = name() {
	                columns.add(column);
	            }
            )*
            ")"
        ]
        (
            stmt = insertStmtWithValues(stmt, columns)
        |   stmt = insertStmtWithSelect(stmt, columns)
        )
    ) {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

InsertStmt insertStmtWithValues(InsertStmt stmt, List<Name> columns) :
{
    InsertStmtWithValues stmtWValues = new InsertStmtWithValues(stmt);
    List<Expression> list = new ArrayList<Expression>();
    Expression expr;

    stmtWValues.columns = columns;
}
{
    "VALUES"
    "("
    expr = expr() {
        list.add(expr);
    }
    (
        ","
	    expr = expr() {
	        list.add(expr);
	    }
    )*
    ")" {
        stmtWValues.rows.add(list);
    }
    (
        "," {
            list = new ArrayList<Expression>();
        }
        "("
        expr = expr() {
	        list.add(expr);
	    }
	    (
	        ","
	        expr = expr() {
	            list.add(expr);
	        }
	    )*
        ")" {
            stmtWValues.rows.add(list);
        }
    )* {
        return stmtWValues;
    }
}
        
InsertStmt insertStmtWithSelect(InsertStmt stmt, List<Name> columns) :
{
    InsertStmtWithSelect stmtWSelect = new InsertStmtWithSelect(stmt);

    stmtWSelect.columns = columns;
}
{
    stmtWSelect.select = selectStmt() {
        return stmtWSelect;
    }
}

PragmaStmt pragmaStmt() :
{
    PragmaStmt stmt = new PragmaStmt();
}
{
    "PRAGMA" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        stmt.database = name() "."
    ]
    stmt.pragma = name()
    [
        "="
        stmt.value = pragmaValue()
    |   "("
        stmt.value = pragmaValue()
        ")"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

PragmaValue pragmaValue() :
{
    UnaryExpr expr;
    StringLiteral literal;
    Name name;
}
{
    (
        expr = signedNumber() {
            return new PragmaNumber(expr, expr);
        }
    |   LOOKAHEAD(<STRING>) // name() that also can match <STRING>
        literal = stringLiteral() {
            return new PragmaString(literal, literal);
        }
    |   name = name() {
            return new PragmaName(name, name);
        }
	)
}

ReindexStmt reindexStmt() :
{
    ReindexStmt stmt = new ReindexStmt();
}
{
    "REINDEX" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        stmt.first = name()
        [
            "."
            stmt.second = name()
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SelectStmt selectStmt() :
{
    SelectStmt stmt = new SelectStmt();
    SelectCompound.Operator operator;
    SelectUnit core;
}
{
    stmt.unit = selectCore() {
        stmt.setBegin(stmt.unit);
    }
    (
        operator = compoundOperator()
        core = selectCore() {
            stmt.unit = new SelectCompound(new Block(stmt.unit.beginLine, stmt.unit.beginColumn,
                token.endLine, token.endColumn), stmt.unit, operator, core);
        }
    )* {
    }
    stmt.constraint = eventConstraint() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SelectCore selectCore() :
{
    SelectCore core = new SelectCore();
    ResultColumn column;
    
    core.columns = new ArrayList<ResultColumn>();}
{
    "SELECT" {
        core.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DISTINCT" {
            core.hasDistinct = true;
        }
    |   "ALL" {			core.hasAll = true;
	    }
    ]
    column = resultColumn() {
        core.columns.add(column);
    }
    (
        ","
        resultColumn() {
	        core.columns.add(column);
	    }
    )*
    [
        "FROM"
        core.from = joinSource()
    ]
    [
        "WHERE"
        core.where = expr()
    ]
    [
        "GROUP" "BY" {
            Expression expr;
            
            core.groupBy = new ArrayList<Expression>();
        }
        expr = expr() {
            core.groupBy.add(expr);
        }
        (
            ","
            expr = expr() {
                core.groupBy.add(expr);
            }
        )*
        [
            "HAVING"
            core.having = expr()
        ]
    ] {
        core.setEnd(token.endLine, token.endColumn);
        return core;
    }
}

ResultColumn resultColumn() :
{
    ResultColumn column;}
{
    (
        LOOKAHEAD(3) // Removes ambiguity between "table.*" and "table.column".
        column = universalColumn()
    |   column = expressionColumn()
    ) {
        return column;
    }}

UniversalColumn universalColumn() :
{
    UniversalColumn column = new UniversalColumn();
}
{
    (
        "*" {
            column.setBeginEnd(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        }
    |   column.table = name()
        "." 
        "*" {
            column.setBeginEnd(column.table.beginLine, column.table.beginColumn, token.endLine,
                token.endColumn);
        }
    ) {
        return column;
    }
}

ExpressionColumn expressionColumn() :
{
    ExpressionColumn column = null;
    Expression expr;
}
{
    expr = expr()
    [
        column = aliasedColumn()
    ] {
        if (column == null) {
            column = new ExpressionColumn();
        }
        column.expr = expr;
        column.setBeginEnd(expr.beginLine, expr.beginColumn, token.endLine, token.endColumn);
        return column;
    }
}

AliasedColumn aliasedColumn() :
{
    AliasedColumn column = new AliasedColumn();
}
{
	[
		"AS" {			column.hasAs = true;
		}
	]
	column.alias = name() {
	    return column;
	}
}

JoinSrc joinSource() :
{
    JoinSrc src;
    JoinCompound.Operator operator;
    JoinSrc right;
    JoinConstraint constraint;}
{
    src = singleSource()
    (
        operator = joinOp()
        right = singleSource()
        constraint = joinConstraint() {
            src = new JoinCompound(new Block(src.beginLine, src.beginColumn, token.endLine,
                token.endColumn), src, operator, right, constraint);
        }
    )* {
        return src;
    }}

JoinSrc singleSource() :
{
    JoinSrc src;
    int line = 0;
    int column = 0;}
{
    (
        src = tableSource()
    |   // To remove ambiguity between selectSource and the joinSource because 
        // both start by "(".
        LOOKAHEAD(2)
        src = selectSource()
    |   "(" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        src = joinSource()
        ")" {
            src.setBeginEnd(line, column, token.endLine, token.endColumn);
        }
    ) {
        return src;
    }}

TableSrc tableSource() :
{
    TableSrc src = new TableSrc();
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        src.database = name() {
            src.setBegin(src.database);
        }
        "."
    ]
    src.table = name() {
        if (src.database == null) {
            src.setBegin(src.table);
        }
    }
    [
        [ "AS" ]
        src.alias = name()
    ]
    src.indexedBy = indexedBy() {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

SelectSrc selectSource() :
{
    SelectSrc src = new SelectSrc();
}
{
    "(" {
        src.setBegin(token.beginLine, token.beginColumn);
    }
    src.select = selectStmt()
    ")"
    [
        [ "AS" ]
        src.alias = name()
    ] {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

JoinCompound.Operator joinOp() :
{}
{
    "," {
        return JoinCompound.Operator.COMMA;
    }
|   "NATURAL" 
    (
        "LEFT" 
        (
            "OUTER" "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_OUTER_JOIN;	        }
	    |   "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_JOIN;
	        }
        )
    |   "INNER" "JOIN" {
            return JoinCompound.Operator.NATURAL_INNER_JOIN;
        }
    |   "CROSS" "JOIN" {
            return JoinCompound.Operator.NATURAL_CROSS_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.NATURAL_JOIN;
        }
    )
|   "LEFT" 
    (
        "OUTER" "JOIN" {
            return JoinCompound.Operator.LEFT_OUTER_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.LEFT_JOIN;
        }
    )
|   "INNER" "JOIN" {
        return JoinCompound.Operator.INNER_JOIN;
    }
|   "CROSS" "JOIN" {
        return JoinCompound.Operator.CROSS_JOIN;
    }
|   "JOIN" {
        return JoinCompound.Operator.JOIN;
    }
}

JoinConstraint joinConstraint() :
{
    JoinConstraint constraint = null;}
{
    [
        constraint = joinConstraintOn()
    |   constraint = joinConstraintUsing()
    ] {
        return constraint;
    }}

JoinConstraintOn joinConstraintOn() :
{
    JoinConstraintOn constraint = new JoinConstraintOn();
}
{
    "ON" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    constraint.expr = expr() {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

JoinConstraintUsing joinConstraintUsing():
{
    JoinConstraintUsing constraint = new JoinConstraintUsing();
    Name column;
    
    constraint.columns = new ArrayList<Name>();
}
{
    "USING" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
	"("
	column = name() {
        constraint.columns.add(column);
    }
    (
        ","
        column = name() {
            constraint.columns.add(column);
        }
    )*
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

OrderingTerm orderingTerm() :
{
    OrderingTerm term = new OrderingTerm();
}
{
    term.expr = expr() {
        term.setBegin(term.expr);
    }
    [
        "ASC" {
            term.order = OrderingTerm.Order.ASC;
        }
    |   "DESC" {
            term.order = OrderingTerm.Order.DESC;
        }
    ] {
        term.setEnd(token.endLine, token.endColumn);
        return term;
    }}

SelectCompound.Operator compoundOperator() :
{
}
{
    "UNION" 
    [ 
        "ALL" {
            return SelectCompound.Operator.UNION_ALL;
        }
    ] {
        return SelectCompound.Operator.UNION;
    }
|   "INTERSECT" {
        return SelectCompound.Operator.INTERSECT;
    }
|   "EXCEPT" {
        return SelectCompound.Operator.EXCEPT;
    }
}

IndexedBy indexedBy() :
{
    IndexedBy indexedBy = new IndexedBy();
}
{
    [
	    (
	        "INDEXED" {
	            indexedBy.setBegin(token.beginLine, token.beginColumn);
            }
            "BY"
	        indexedBy.index = name()
	    |   "NOT" {
                indexedBy.setBegin(token.beginLine, token.beginColumn);
				indexedBy.notIndexed = true;
            }
            "INDEXED"
	    ) {
            indexedBy.setEnd(token.endLine, token.endColumn);
            return indexedBy;
        }
    ] {
        return null;
    }
}

UpdateStmt updateStmt() :
{
    UpdateStmt stmt = new UpdateStmt();
    ColumnAssignment assignment;
    
    stmt.assignments = new ArrayList<ColumnAssignment>();
}
{
    "UPDATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
        stmt.type = UpdateStmt.Type.UPDATE;
    }
    [
        "OR"
        (
            "ROLLBACK" {
                stmt.type = UpdateStmt.Type.UPDATE_OR_ROLLBACK;
            }
        |   "ABORT" {
                stmt.type = UpdateStmt.Type.UPDATE_OR_ABORT;
            }
        |   "REPLACE" {
                stmt.type = UpdateStmt.Type.UPDATE_OR_REPLACE;
            }
        |   "FAIL" {
                stmt.type = UpdateStmt.Type.UPDATE_OR_FAIL;
            }
        |   "IGNORE" {
                stmt.type = UpdateStmt.Type.UPDATE_OR_IGNORE;
            }
        )
    ]
    stmt.qualifiedTable = qualifiedTableName()
    "SET"
    assignment = columnAssignment() {
        stmt.assignments.add(assignment);
    }
    (
        ","
	    assignment = columnAssignment() {
	        stmt.assignments.add(assignment);
	    }
    )*
    [
        "WHERE"
        stmt.where = expr()
    ]
    stmt.constraint = eventConstraint() {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

QualifiedTableName qualifiedTableName() :
{
    QualifiedTableName qualifiedTable = new QualifiedTableName();
}
{
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        qualifiedTable.database = name() {
            qualifiedTable.setBegin(qualifiedTable.database);
        }
        "."
    ]
    qualifiedTable.table = name() {
        if (qualifiedTable.database == null) {
            qualifiedTable.setBegin(qualifiedTable.table);
        }
    }
    qualifiedTable.indexedBy = indexedBy() {
        qualifiedTable.setEnd(token.endLine, token.endColumn);
        return qualifiedTable;
    }
}

ColumnAssignment columnAssignment() :
{
    Name column;
    Expression expr;
}
{
    column = name()
    "="
    expr = expr() {
        return new ColumnAssignment(new Block(column.beginLine, column.beginColumn, token.endLine,
            token.endColumn), column, expr);
    }
}


VacuumStmt vacuumStmt() :
{
}
{
    "VACUUM" {
        VacuumStmt stmt = new VacuumStmt();
        stmt.setBeginEnd(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        return stmt;
    }
}