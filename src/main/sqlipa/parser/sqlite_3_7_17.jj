options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
    COMMON_TOKEN_ACTION = true;
    IGNORE_CASE = true;
}

PARSER_BEGIN(ASTParser)
package main.sqlipa.parser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.LinkedList;

import main.sqlipa.parser.ast.*;
import main.sqlipa.parser.ast.constraint.*;
import main.sqlipa.parser.ast.constraint.table.*;
import main.sqlipa.parser.ast.constraint.column.*;
import main.sqlipa.parser.ast.expr.*;
import main.sqlipa.parser.ast.literal.*;
import main.sqlipa.parser.ast.stmt.*;
import main.sqlipa.parser.ast.stmt.create.*;
import main.sqlipa.parser.ast.stmt.drop.*;
import main.sqlipa.parser.ast.stmt.event.*;
import main.sqlipa.parser.ast.stmt.event.select.*;
import main.sqlipa.parser.ast.stmt.event.update.*;
import main.sqlipa.parser.ast.stmt.pragma.*;

final class ASTParser {

    public static void main(String[] args) {
        String str =
            "CREATE TABLE IF NOT EXISTS lyrics(" +
            "lyric_id INTEGER PRIMARY KEY AUTOINCREMENT," +
            "title TEXT," +
            "subtitle TEXT);";
 
        InputStream is = new ByteArrayInputStream(str.getBytes());
        ASTParser parser = new ASTParser(is);
        try {
            parser.sqlStmtList();
            System.out.println("Ok.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} 
PARSER_END(ASTParser)

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\f"
|   "\r"
}

/* Comments */
SPECIAL_TOKEN :
{
    <LINE_COMMENT: "--" (~["\n"])* "\n">
}

MORE :
{
    "/*": IN_BLOCK_COMMENT
}

<IN_BLOCK_COMMENT> MORE :
{
    <~[]>
}

<IN_BLOCK_COMMENT> SPECIAL_TOKEN :
{
    <BLOCK_COMMENT: "*/">: DEFAULT
}

TOKEN_MGR_DECLS :
{
    // TODO: correct comments.
    private List<Comment> comments = new LinkedList<Comment>();
    
    private void CommonTokenAction(Token token) {
        token = token.specialToken;
        while (token != null) {
            if (token.kind == LINE_COMMENT) {
                comments.add(new LineComment(new Block(token.beginLine,
                    token.beginColumn, token.endLine, token.endColumn), 
                    token.image));
            } else if (token.kind == BLOCK_COMMENT) {
                comments.add(new BlockComment(new Block(token.beginLine,
                    token.beginColumn, token.endLine, token.endColumn), 
                    token.image));
            } else {
                break;
            }
            token = token.specialToken;
        }
    }
    
    public List<Comment> popComments() {
        List<Comment> ret = comments;
        comments = new LinkedList<Comment>();
        return ret;
    }
    
    public List<Comment> peekComments() {
        return comments;
    }
}

/* Keywords */
TOKEN :
{
    <ABORT: "ABORT">
|   <ACTION: "ACTION">
|   <ADD: "ADD">
|   <AFTER: "AFTER">
|   <ALL: "ALL">
|   <ALTER: "ALTER">
|   <ANALYZE: "ANALYZE">
|   <AND: "AND">
|   <AS: "AS">
|   <ASC: "ASC">
|   <ATTACH: "ATTACH">
|   <AUTOINCREMENT: "AUTOINCREMENT">
|   <BEFORE: "BEFORE">
|   <BEGIN: "BEGIN">
|   <BETWEEN: "BETWEEN">
|   <BY: "BY">
|   <CASCADE: "CASCADE">
|   <CASE: "CASE">
|   <CAST: "CAST">
|   <CHECK: "CHECK">
|   <COLLATE: "COLLATE">
|   <COLUMN: "COLUMN">
|   <COMMIT: "COMMIT">
|   <CONFLICT: "CONFLICT">
|   <CONSTRAINT: "CONSTRAINT">
|   <CREATE: "CREATE">
|   <CROSS: "CROSS">
|   <CURRENT_DATE: "CURRENT_DATE">
|   <CURRENT_TIME: "CURRENT_TIME">
|   <CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <DATABASE: "DATABASE">
|   <DEFAULT_: "DEFAULT">
|   <DEFERRABLE: "DEFERRABLE">
|   <DEFERRED: "DEFERRED">
|   <DELETE: "DELETE">
|   <DESC: "DESC">
|   <DETACH: "DETACH">
|   <DISTINCT: "DISTINCT">
|   <DROP: "DROP">
|   <EACH: "EACH">
|   <ELSE: "ELSE">
|   <END: "END">
|   <ESCAPE: "ESCAPE">
|   <EXCEPT: "EXCEPT">
|   <EXCLUSIVE: "EXCLUSIVE">
|   <EXISTS: "EXISTS">
|   <EXPLAIN: "EXPLAIN">
|   <FAIL: "FAIL">
|   <FOR: "FOR">
|   <FOREIGN: "FOREIGN">
|   <FROM: "FROM">
|   <FULL: "FULL">
|   <GLOB: "GLOB">
|   <GROUP: "GROUP">
|   <HAVING: "HAVING">
|   <IF: "IF">
|   <IGNORE: "IGNORE">
|   <IMMEDIATE: "IMMEDIATE">
|   <IN: "IN">
|   <INDEX: "INDEX">
|   <INDEXED: "INDEXED">
|   <INITIALLY: "INITIALLY">
|   <INNER: "INNER">
|   <INSERT: "INSERT">
|   <INSTEAD: "INSTEAD">
|   <INTERSECT: "INTERSECT">
|   <INTO: "INTO">
|   <IS: "IS">
|   <ISNULL: "ISNULL">
|   <JOIN: "JOIN">
|   <KEY: "KEY">
|   <LEFT: "LEFT">
|   <LIKE: "LIKE">
|   <LIMIT: "LIMIT">
|   <MATCH: "MATCH">
|   <NATURAL: "NATURAL">
|   <NO: "NO">
|   <NOT: "NOT">
|   <NOTNULL: "NOTNULL">
|   <NULL: "NULL">
|   <OF: "OF">
|   <OFFSET: "OFFSET">
|   <ON: "ON">
|   <OR: "OR">
|   <ORDER: "ORDER">
|   <OUTER: "OUTER">
|   <PLAN: "PLAN">
|   <PRAGMA: "PRAGMA">
|   <PRIMARY: "PRIMARY">
|   <QUERY: "QUERY">
|   <RAISE: "RAISE">
|   <REFERENCES: "REFERENCES">
|   <REGEXP: "REGEXP">
|   <REINDEX: "REINDEX">
|   <RELEASE: "RELEASE">
|   <RENAME: "RENAME">
|   <REPLACE: "REPLACE">
|   <RESTRICT: "RESTRICT">
|   <RIGHT: "RIGHT">
|   <ROLLBACK: "ROLLBACK">
|   <ROW: "ROW">
|   <SAVEPOINT: "SAVEPOINT">
|   <SELECT: "SELECT">
|   <SET: "SET">
|   <TABLE: "TABLE">
|   <TEMP: "TEMP">
|   <TEMPORARY: "TEMPORARY">
|   <THEN: "THEN">
|   <TO: "TO">
|   <TRANSACTION: "TRANSACTION">
|   <TRIGGER: "TRIGGER">
|   <UNION: "UNION">
|   <UNIQUE: "UNIQUE">
|   <UPDATE: "UPDATE">
|   <USING: "USING">
|   <VACUUM: "VACUUM">
|   <VALUES: "VALUES">
|   <VIEW: "VIEW">
|   <VIRTUAL: "VIRTUAL">
|   <WHEN: "WHEN">
|   <WHERE: "WHERE">
}

/* Operators */
TOKEN :
{
    <CONCATENATION: "||">
|   <STAR: "*">
|   <SLASH: "/">
|   <MODULO: "%">
|   <PLUS: "+">
|   <MINUS: "-">
|   <SHIFT_HIGH: "<<">
|   <SHIFT_LOW: ">>">
|   <BIT_AND: "&">
|   <BIT_OR: "|">
|   <BIT_NOT: "~">
|   <LESS: "<">
|   <LESS_OR_EQUAL: "<=">
|   <GREATER: ">">
|   <GREATER_OR_EQUAL: ">=">
|   <EQUAL_1: "=">
|   <EQUAL_2: "==">
|   <NOT_EQUAL_1: "!=">
|   <NOT_EQUAL_2: "<>">
}

/* Literals & Identifiers */
TOKEN :
{
    <NUMERIC:
        (
            (<DIGIT>)+ (<DOT> (<DIGIT>)*)?
        |   <DOT> (<DIGIT>)+
        )
        (<EXPONENT>)?
    >
|   <#EXPONENT: "E" (["+", "-"])? (<DIGIT>)+>
|   <STRING: "'" (~["'"])* ("''" (~["'"])*)* "'">
|   <BLOB: "X'" (<HEX_CHAR> <HEX_CHAR>)* "'">
|   <PARAMETER: 
        "?" (<DIGIT>)*
    |   (":" | "@" | "$") // sqlite implementation also allows '#'.
        ("::")?
        <CHAR>
        (<CHAR> | "::")*
        (
            "("
            (~[")", "\t", "\n", "\f", "\r", " "])*
            ")"
        )?
    >
|   <ID: 
        <CHAR> (<CHAR> | <DIGIT>)*
    |   "\"" (~["\""])* ("\"\"" (~["\""])*)* "\""
    |   "`" (~["`"])* ("``" (~["`"])*)* "`"
    |   "[" (~["]"])* "]"
    >
}

/* Separators */
TOKEN :
{
    <LP: "(">
|   <RP: ")">
|   <SEMICOLON: ";">
|   <COMMA: ",">
|   <DOT: ".">
|   <NOT_COMMA_LP_RP: (~[",", "(", ")"])+>
|   <NOT_LP_RP: (~["(", ")"])+>
}

/* Char Sets */
TOKEN :
{
    <#DIGIT: ["0" - "9"]>
    // Has mentioned in sqlite implementation '$' is not documented but is
    // implemented for compatibility.
|   <#CHAR: ["A" - "Z", "_", "$"]>
|   <#HEX_CHAR: ["0" - "9", "A" - "F"]>
}

/* Grammar */
List<SqlStatement> sqlStmtList() :{
    List<SqlStatement> stmts = new LinkedList<SqlStatement>();    SqlStatement stmt;
}
{
    [
	    stmt = sqlStmt() {
	        stmts.add(stmt);
	    }
	    (
	        ";"
	        [
		        stmt = sqlStmt() {
	                stmts.add(stmt);
	            }
            ]
	    )*
    ] {
        return stmts;
    }
}

SqlStatement sqlStmt() :
{
    int line = 0;
    int column = 0;
    SqlStatement.Explain explain = null;
    SqlStatement stmt;
}
{    [   
        "EXPLAIN" {
            line = token.beginLine;
            column = token.beginColumn;
            explain = SqlStatement.Explain.NORMAL;
        } 
        ["QUERY" "PLAN"] {
            explain = SqlStatement.Explain.PLAN;
        }
    ]
    (
        stmt = alterTableStmt()
    |   stmt = analyzeStmt()
    |   stmt = attachStmt()
	|   stmt = beginStmt()
	|   stmt = commitStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createTableStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createTriggerStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
        stmt = createViewStmt()
	|   stmt = createVirtualTableStmt()	|   stmt = deleteStmt()
	|   stmt = detachStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
	    stmt = dropIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        stmt = dropTableStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        stmt = dropTriggerStmt()
	|   stmt = dropViewStmt()
	|   stmt = insertStmt()
	|   stmt = pragmaStmt()
	|   stmt = reindexStmt()
	|   stmt = releaseStmt()
	|   stmt = rollbackStmt()
	|   stmt = savepointStmt()
	|   stmt = selectStmt()
	|   stmt = updateStmt()
	|   stmt = vacuumStmt()
	) {
        if (explain != null) {
            // If statement starts by EXPLAIN.
            stmt.setBegin(line, column);
            stmt.setExplain(explain);
        }
        return stmt;
    }
}

Name name() :
{
}
{
    (
        <ID>
    |   <STRING>
    ) {
        return new Name(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

AlterTableStmt alterTableStmt() :
{
    AlterTableStmt stmt;
    int line;
    int column;
    Name database = null;
    Name table;
}
{
    "ALTER" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    "TABLE"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    (
        stmt = renameTableStmt()
    |   stmt = addColumnStmt()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.setDatabase(database);
        stmt.setTable(table);
        return stmt;
    }
}

AlterTableStmt renameTableStmt() :
{
    RenameTableStmt stmt = new RenameTableStmt();
    Name table;
}
{
    "RENAME" "TO"
    table = name() {
        stmt.setNewTable(table);
        return stmt;
    }
}

AlterTableStmt addColumnStmt() :
{
    AddColumnStmt stmt = new AddColumnStmt();
    ColumnDef column;
}
{
    "ADD" [ "COLUMN" ]
    column = columnDef() {
        stmt.setColumn(column);
        return stmt;
    }
}

AnalyzeStmt analyzeStmt() :
{
    AnalyzeStmt stmt = new AnalyzeStmt();
    Name first = null;
    Name second = null;
}
{
    "ANALYZE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        first = name()
        [
            "."
            second = name()
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setFirstName(first);
        stmt.setSecondName(second);
        return stmt;
    }
}

AttachStmt attachStmt() :
{
    AttachStmt stmt = new AttachStmt();
    Expression expr;
    Name database;
}
{
    "ATTACH" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DATABASE"
    ]
    expr = expr()
    "AS"
    database = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setExpression(expr);
        stmt.setDatabase(database);
        return stmt;
    }
}

BeginStmt beginStmt() :
{
    BeginStmt stmt = new BeginStmt();
}
{
    "BEGIN" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DEFERRED" {
            stmt.setType(BeginStmt.Type.DEFERRED);
        }
    |   "IMMEDIATE" {
            stmt.setType(BeginStmt.Type.IMMEDIATE);
        }
    |   "EXCLUSIVE" {
            stmt.setType(BeginStmt.Type.EXCLUSIVE);
        }
    ]
    [
        "TRANSACTION"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CommitStmt commitStmt() :
{
    CommitStmt stmt = new CommitStmt();
}
{
    (
        "COMMIT"
    |   "END"
    ) {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "TRANSACTION"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

RollbackStmt rollbackStmt() :
{
    RollbackStmt stmt = new RollbackStmt();
}
{
    "ROLLBACK"  {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [ "TRANSACTION" ]
    [
        "TO" {
            Name savepoint;
        }
        [ "SAVEPOINT" ]
        savepoint = name() {
            stmt.setSavepoint(savepoint);
        }
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SavepointStmt savepointStmt() :
{
    SavepointStmt stmt = new SavepointStmt();
    Name savepoint;
}
{
    "SAVEPOINT"  {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    savepoint = name() {
        stmt.setSavepoint(savepoint);
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

ReleaseStmt releaseStmt() :
{
    ReleaseStmt stmt = new ReleaseStmt();
    Name savepoint;
}
{
    "RELEASE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [ "SAVEPOINT" ]
    savepoint = name() {
        stmt.setSavepoint(savepoint);
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

CreateIndexStmt createIndexStmt() :
{
    CreateIndexStmt stmt = new CreateIndexStmt();
    Name database = null;
    Name index;
    Name table;
    IndexedColumn column;
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "UNIQUE" { 
            stmt.setUnique(true);
        }
    ]
    "INDEX"
    [
        "IF" "NOT" "EXISTS" { 
            stmt.setIfNotExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    index = name()
    "ON"
    table = name()
    "("
    column = indexedColumn() {
        stmt.addColumn(column);
    }
    (
        ","
	    column = indexedColumn() {
	        stmt.addColumn(column);
	    }
    )*
    ")" {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(index);
        stmt.setDatabase(database);
        stmt.setTable(table);
        return stmt;
    }
}

IndexedColumn indexedColumn() :
{
    IndexedColumn indColumn = new IndexedColumn();
    Name column;
}
{
    column = name() {
        indColumn.setColumn(column);
        indColumn.setBegin(column);
    }
    [
        "COLLATE" {
            Name collation;
        }
        collation = name() {
            indColumn.setCollation(collation);
        }
    ]
    [
        "ASC" {
            indColumn.setOrder(IndexedColumn.Order.ASC);
        }
    |   "DESC" {
            indColumn.setOrder(IndexedColumn.Order.DESC);
        }
    ] {
        indColumn.setEnd(token.endLine, token.endColumn);
        return indColumn;
    }}

CreateTableStmt createTableStmt() :
{
    CreateTableStmt stmt;
    int line;
    int column;
    boolean hasTemp = false;
    boolean hasIfNotExists = false;
    Name database = null;
    Name table;
}
{
    "CREATE" {
        line = token.beginLine;
        column = token.beginColumn; 
    }
    [
        ("TEMP" | "TEMPORARY") { 
            hasTemp = true;
        }
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" { 
            hasIfNotExists = true;
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    (
        stmt = createTableStmtWithColumns()
    |   stmt = createTableStmtWithSelect()
    ) {
        stmt.setBeginEnd(line, column, token.endLine, token.endColumn);
        stmt.setTemporary(hasTemp);
        stmt.setIfNotExists(hasIfNotExists);
        stmt.setName(table);
        stmt.setDatabase(database);
        return stmt;
    }}

CreateTableStmt createTableStmtWithColumns() :
{
    CreateTableStmtWithColumns stmt = new CreateTableStmtWithColumns();
    ColumnDef column;
}
{
    "("
    column = columnDef() { 
        stmt.addColumn(column);
    }
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHEAD(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        ","
        column = columnDef() {
            stmt.addColumn(column);
        }
    )* 
    (   
        "," {
            TableConstraint constraint;
        }
        constraint = tableConstraint() { 
            stmt.addConstraint(constraint);
        }
    )*
    ")" {
        return stmt;
    }
}

CreateTableStmt createTableStmtWithSelect() :
{
    CreateTableStmtWithSelect stmt = new CreateTableStmtWithSelect();
    SelectStmt select;
}
{
    "AS"
    select = selectStmt() {
        stmt.setSelect(select);
        return stmt;
    }
}

ColumnDef columnDef() :
{
    ColumnDef columnDef = new ColumnDef();
    Name column;
    TypeName type;
    ColumnConstraint constraint;}
{
    column = name() {
        columnDef.setColumn(column);
        columnDef.setBegin(column);
    }
    [
        type = typeName() {
            columnDef.setType(type);
        }
    ]
    (
        constraint = columnConstraint() {
            columnDef.addConstraint(constraint);
        }
    )* {
        columnDef.setEnd(token.endLine, token.endColumn);
        return columnDef;
    }}

TypeName typeName() :
{
    TypeName type = new TypeName();
    String name = new String();
    
    type.setName(name);}
{
    name() {
        type.setBegin(token.beginLine, token.beginColumn);
        name += token.image;
    }
    (
        name() {
            name += " " + token.image;
        }
    )*
    [
        "(" {
            UnaryExpr xDim;
        }
        xDim = signedNumber() {
            type.setDimensionInX(xDim);
        }
        [
            "," {
                UnaryExpr yDim;
            }
            yDim = signedNumber() {
                type.setDimensionInY(yDim);
            }
        ]
        ")"
    ] {
        type.setEnd(token.endLine, token.endColumn);
        return type;
    }}

ColumnConstraint columnConstraint() :
{
    ColumnConstraint constraint;
    int line = 0;
    int column = 0;
    Name name = null;}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = name()
    ]
    (
        constraint = primaryKeyColumnConstraint()
    |   constraint = notNullColumnConstraint()
    |   constraint = uniqueColumnConstraint()
    |   constraint = checkColumnConstraint()
    |   constraint = defaultColumnConstraint()    |   constraint = collateColumnConstraint()
    |   constraint = foreignKeyColumnConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }
}

PrimaryKeyColumnConstraint primaryKeyColumnConstraint() :
{
    PrimaryKeyColumnConstraint constraint = new PrimaryKeyColumnConstraint();
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY" 
    [
        "ASC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.ASC);
        }
    |   "DESC" {
            constraint.setOrder(PrimaryKeyColumnConstraint.Order.DESC);
        }
    ]
    clause = conflictClause() {
        constraint.setClause(clause);
    }
    [
        "AUTOINCREMENT" {
            constraint.setAutoincrement(true);
        }
    ] {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

NotNullColumnConstraint notNullColumnConstraint() :
{
    NotNullColumnConstraint constraint = new NotNullColumnConstraint();
    ConflictClause clause;
}
{
    "NOT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "NULL"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueColumnConstraint uniqueColumnConstraint() :
{
    UniqueColumnConstraint constraint = new UniqueColumnConstraint();
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckColumnConstraint checkColumnConstraint() :
{
    CheckColumnConstraint constraint = new CheckColumnConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    expr = expr()
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

DefaultColumnConstraint defaultColumnConstraint() :
{
    DefaultColumnConstraint constraint = new DefaultColumnConstraint();
    Expression expr;
    Literal literal;
}
{
    "DEFAULT" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    (
        // As signedNumber and literalValue match a numericLiteral() it is only
        // consider to exist a signedNumber if actually there is sign.
        LOOKAHEAD("+" | "-")
        expr = signedNumber()
    |   literal = literalValue() {
            expr = new LiteralExpr(literal, literal);
        }
    |   "("
        expr = expr()
        ")"
    ) {
        constraint.setEnd(token.endLine, token.endColumn);
        constraint.setExpression(expr);
        return constraint;
    }
}

CollateColumnConstraint collateColumnConstraint() :
{
    CollateColumnConstraint constraint = new CollateColumnConstraint();
    Name collation;
}
{
    "COLLATE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    collation = name() {
        constraint.setCollation(collation);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyColumnConstraint foreignKeyColumnConstraint() :
{
    ForeignKeyColumnConstraint constraint = new ForeignKeyColumnConstraint();
    ForeignKeyClause clause;
}
{
    clause = foreignKeyClause() {
        constraint.setBeginEnd(clause);
        constraint.setClause(clause);
        return constraint;
    }
}

UnaryExpr signedNumber() :
{
    UnaryExpr number = new UnaryExpr();
    NumericLiteral literal;}
{
    [
        (
            "+" {
                number.setOperator(UnaryExpr.Operator.POSITIVE);
            }
        |   "-" {
                number.setOperator(UnaryExpr.Operator.NEGATIVE);
            }
        ) {
            number.setBegin(token.beginLine, token.beginColumn);
        }
    ]
    literal = numericLiteral() {
        if (number.getOperator() == null) {
            number.setBeginEnd(literal);
        } else {
            number.setEnd(token.endLine, token.endColumn);
        }
        number.setExpression(new LiteralExpr(literal, literal));
        return number;
    }}

TableConstraint tableConstraint() :
{
    TableConstraint constraint;    int line = 0;
    int column = 0;
    Name name = null;
}
{
    [
        "CONSTRAINT" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        name = name()
    ]
    (
        constraint = primaryKeyTableConstraint()
    |   constraint = checkTableConstraint()
    |   constraint = foreignKeyTableConstraint()
    ) {
        if (name != null) {
            constraint.setBegin(line, column);
            constraint.setName(name);
        }
        return constraint;
    }}

PrimaryKeyTableConstraint primaryKeyTableConstraint() :
{
    PrimaryKeyTableConstraint constraint = new PrimaryKeyTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "PRIMARY" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

UniqueTableConstraint uniqueTableConstraint() :
{
    UniqueTableConstraint constraint = new UniqueTableConstraint();
    IndexedColumn column;
    ConflictClause clause;
}
{
    "UNIQUE" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "(" 
    column = indexedColumn() {
        constraint.addColumn(column);
    }
    (
        ","
        column = indexedColumn() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = conflictClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

CheckTableConstraint checkTableConstraint() :
{
    CheckTableConstraint constraint = new CheckTableConstraint();
    Expression expr;
}
{
    "CHECK" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() 
    ")" {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyTableConstraint foreignKeyTableConstraint() :
{
    ForeignKeyTableConstraint constraint = new ForeignKeyTableConstraint();
    Name column;
    ForeignKeyClause clause;
}
{
    "FOREIGN" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    "KEY"
    "("
    column = name() {
        constraint.addColumn(column);
    }
    (
        "," 
        column = name() {
            constraint.addColumn(column);
        }
    )*
    ")"
    clause = foreignKeyClause() {
        constraint.setClause(clause);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

ForeignKeyClause foreignKeyClause() :
{
    ForeignKeyClause clause = new ForeignKeyClause();
    Block block = new Block();
    Name table;
    ForeignKeySetting sett;}
{
    "REFERENCES" {
        clause.setBegin(token.beginLine, token.beginColumn);
    }
    table = name() {
        clause.setTable(table);
    }
    [
        "(" {
            Name column;
        }
        column = name() {
            clause.addColumn(column);
        }
        (
            ","
            column = name() {
                clause.addColumn(column);
            }
        )*
        ")"
    ]
    (
        sett = onSetting() {
            clause.addSetting(sett);
        }
    |   sett = matchSetting() {
            clause.addSetting(sett);
        }
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
        sett = deferrableSetting() {
            clause.addSetting(sett);
        }
    ] {
        clause.setEnd(token.endLine, token.endColumn);
        return clause;
    }}

OnSetting onSetting() :
{
    OnSetting sett = new OnSetting();
}
{
    "ON" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    (
        "DELETE" {
            sett.setEvent(OnSetting.Event.DELETE);
        }
    |   "UPDATE" {
            sett.setEvent(OnSetting.Event.UPDATE);
        }
    )
    (
        "SET"
        (
            "NULL" {
                sett.setAction(OnSetting.Action.SET_NULL);
            }
        |   "DEFAULT" {
                sett.setAction(OnSetting.Action.SET_DEFAULT);
            }
        )
    |   "CASCADE" {
            sett.setAction(OnSetting.Action.CASCADE);
        }
    |   "RESTRICT" {
            sett.setAction(OnSetting.Action.RESTRICT);
        }
    |   "NO" "ACTION" {
            sett.setAction(OnSetting.Action.NO_ACTION);
        }
    ) {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

MatchSetting matchSetting() :
{
    MatchSetting sett = new MatchSetting();
}
{
    "MATCH" {
        sett.setBegin(token.beginLine, token.beginColumn);
    }
    name() {
        sett.setName(new Name(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image));
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

DeferrableSetting deferrableSetting() :
{
    DeferrableSetting sett = new DeferrableSetting();
}
{
    (
        "NOT" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableSetting.Type.NOT_DEFERRABLE);
        }
        "DEFERRABLE"
    |   "DEFERRABLE" {
            sett.setBegin(token.beginLine, token.beginColumn);
            sett.setType(DeferrableSetting.Type.DEFERRABLE);
        }
    )
    [
        "INITIALLY"
        (
            "DEFERRED" {
                sett.setMode(DeferrableSetting.Mode.DEFERRED);
            }
        |   "IMMEDIATE" {
                sett.setMode(DeferrableSetting.Mode.IMMEDIATE);
            }
        )
    ] {
        sett.setEnd(token.endLine, token.endColumn);
        return sett;
    }
}

ConflictClause conflictClause() :
{
}
{
    [   
        "ON" {
            ConflictClause clause = new ConflictClause();
            clause.setBegin(token.beginLine, token.beginColumn);
        }
        "CONFLICT"
        (
            "ROLLBACK" {
                clause.setAction(ConflictClause.Action.ROLLBACK);
            }
        |   "ABORT" {
                clause.setAction(ConflictClause.Action.ABORT);
            }
        |   "FAIL" {
                clause.setAction(ConflictClause.Action.FAIL);
            }
        |   "IGNORE" {
                clause.setAction(ConflictClause.Action.IGNORE);
            }
        |   "REPLACE" {
                clause.setAction(ConflictClause.Action.REPLACE);
            }
        ) {
            clause.setEnd(token.endLine, token.endColumn);
            return clause;
        }
    ] {
        return null;
    }}

CreateTriggerStmt createTriggerStmt() :
{
    CreateTriggerStmt stmt = new CreateTriggerStmt();
    boolean hasIfNotExists = false;
    Name database = null;
    Name trigger;
    Name table;
    EventStmt eventStmt;
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        ("TEMP" | "TEMPORARY") {
            stmt.setTemporary(true);
        }
    ]
    "TRIGGER"
    [
        "IF" "NOT" "EXISTS" {
            stmt.setIfNotExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    trigger = name()
    [
        "BEFORE" {
            stmt.setTime(CreateTriggerStmt.Time.BEFORE);
        }
    |   "AFTER" {
            stmt.setTime(CreateTriggerStmt.Time.AFTER);
        }
    |   "INSTEAD" "OF" {
            stmt.setTime(CreateTriggerStmt.Time.INSTEAD_OF);
        }
    ]
    (
        "DELETE" {
            stmt.setEvent(CreateTriggerStmt.Event.DELETE);
        }
    |   "INSERT"  {
            stmt.setEvent(CreateTriggerStmt.Event.INSERT);
        }
    |   "UPDATE" {
            stmt.setEvent(CreateTriggerStmt.Event.DELETE);
        }
        [
            "OF" {
                Name column;
            }
            column = name() {
                stmt.addColumn(column);
            }
            (
                ","
                column = name() {
                    stmt.addColumn(column);
                }
            )*
        ]
    )
    "ON"
    table = name()
    [
        "FOR" "EACH" "ROW" {
            stmt.setForEachRow(true);
        }
    ]
    [
        "WHEN" {
            Expression expr;
        }
        expr = expr() {
            stmt.setWhen(expr);
        }
    ]
    "BEGIN"
    (
        (
            eventStmt = updateStmt()
        |   eventStmt = insertStmt()
        |   eventStmt = deleteStmt()
        |   eventStmt = selectStmt()
        ) {
            stmt.addStatement(eventStmt);
        }
        ";"
    )+
    "END" {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(trigger);
        stmt.setDatabase(database);
        stmt.setTable(table);
        return stmt;
    }
}

CreateViewStmt createViewStmt() :
{
    CreateViewStmt stmt = new CreateViewStmt();
    Name database = null;
    Name view;
    SelectStmt select;
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        ("TEMP" | "TEMPORARY") {
            stmt.setTemporary(true);
        }
    ]
    "VIEW"
    [
        "IF" "NOT" "EXISTS" {
            stmt.setIfNotExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    view = name()
    "AS"
    select = selectStmt() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(view);
        stmt.setDatabase(database);
        stmt.setSelect(select);
        return stmt;
    }
}

CreateVirtualTableStmt createVirtualTableStmt() :
{
    CreateVirtualTableStmt stmt = new CreateVirtualTableStmt();
    Name database = null;
    Name table;
    Name module;
}
{
    "CREATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "VIRTUAL" "TABLE"
    [
        "IF" "NOT" "EXISTS" {
            stmt.setIfNotExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    "USING"
    module = name()
    [
        "(" {
            ModuleArgument arg;
        }
        arg = moduleArgument() {
            stmt.addModuleArgument(arg);
        }
        (
            ","
            arg = moduleArgument() {
                stmt.addModuleArgument(arg);
            }
        )*
        ")"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(module);
        stmt.setDatabase(database);
        return stmt;
    }
}

ModuleArgument moduleArgument() :
{
}
{
    // TODO:
    (<NOT_COMMA_LP_RP>)*
    [
	    "("
        other()
	    ")"
    ]
    (<NOT_COMMA_LP_RP>)* {
        return new ModuleArgument(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

void other() :
{
}
{
    (<NOT_LP_RP>)*
    [
	    "("
        other()
	    ")"
    ]
    (<NOT_LP_RP>)*
}

DeleteStmt deleteStmt() :
{
    DeleteStmt stmt = new DeleteStmt();
    QualifiedTableName qualifiedTable;
    EventConstraint constraint = null;
}
{
    "DELETE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "FROM"
    qualifiedTable = qualifiedTableName()
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            stmt.setWhere(expr);
        }
    ]
    constraint = eventConstraint() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setQualifiedTable(qualifiedTable);
        stmt.setConstraint(constraint);
        return stmt;
    }
}

EventConstraint eventConstraint() :
{
    EventConstraint constraint = null;
}
{
    [
        "ORDER" {
            constraint = new EventConstraint();
            constraint.setBegin(token.beginLine, token.beginColumn);
            OrderingTerm term;
        }
        "BY"
        term = orderingTerm() {
            constraint.addTerm(term);
        }
        (
            ","
            term = orderingTerm() {
                constraint.addTerm(term);
            }
        )*
    ]
    [
        "LIMIT" {
            if (constraint == null) {
                constraint = new EventConstraint();
                constraint.setBegin(token.beginLine, token.beginColumn);
            }
            Expression expr;
        }
        expr = expr() {
            constraint.setLimit(expr);
        }
        [
            ( "OFFSET" | "," )
            expr = expr() {
                constraint.setOffset(expr);
            }
        ]
    ] {
        if (constraint != null) {
            constraint.setEnd(token.endLine, token.endColumn);
        }
        return constraint;
    }
}

DetachStmt detachStmt() :
{
    DetachStmt stmt = new DetachStmt();
    Name database;
}
{
    "DETACH" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [ "DATABASE" ]
    database = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setDatabase(database);
        return stmt;
    }
}

DropIndexStmt dropIndexStmt() :
{
    DropIndexStmt stmt = new DropIndexStmt();
    Name database = null;
    Name index;
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "INDEX"
    [
        "IF" "EXISTS" {
            stmt.setIfExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    index = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(index);
        stmt.setDatabase(database);
        return stmt;
    }
}

DropTableStmt dropTableStmt() :
{
    DropTableStmt stmt = new DropTableStmt();
    Name database = null;
    Name table;
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "TABLE"
    [
        "IF" "EXISTS" {
            stmt.setIfExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(table);
        stmt.setDatabase(database);
        return stmt;
    }
}

DropTriggerStmt dropTriggerStmt() :
{
    DropTriggerStmt stmt = new DropTriggerStmt();
    Name database = null;
    Name trigger;
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "TRIGGER"
    [
        "IF" "EXISTS" {
            stmt.setIfExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    trigger = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(trigger);
        stmt.setDatabase(database);
        return stmt;
    }
}

DropViewStmt dropViewStmt() :
{
    DropViewStmt stmt = new DropViewStmt();
    Name database = null;
    Name view;
}
{
    "DROP" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    "VIEW"
    [
        "IF" "EXISTS" {
            stmt.setIfExists(true);
        }
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    view = name() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setName(view);
        stmt.setDatabase(database);
        return stmt;
    }
}

// Expression is built by parts recursively to ensure operator precedences are
// to avoid left recursion.
Expression expr() :
{
    Expression left;
    Expression right;
}
{
    left = andExpr()   
    (
        "OR"
        right = andExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.OR);
        }
    )* {
        return left;
    }
}

Expression andExpr() :
{
    Expression left;
    Expression right;
}
{
    left = notExpr()
    (
        "AND"
        right = notExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.AND);
        }
    )* {
        return left;
    }
}

Expression notExpr() :
{
    Expression expr;
}
{
    (
        "NOT" {
            int line = token.beginLine;
            int column = token.beginColumn;
        }
        expr = notExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), UnaryExpr.Operator.LOGICAL_NOT, expr);
        }
    |   expr = equalityExpr() 
    ) {
        return expr;
    }
}

Expression equalityExpr() :
{
    Expression expr;
}
{
    expr = relationalExpr()
    // All types of expressions in this choice point can start by "NOT". 
    // LOOKAHEAD removes ambiguity which one to choose.
    (
        LOOKAHEAD(2)
        expr = unaryEqualityExpr(expr)
    |   LOOKAHEAD(2)
        expr = betweenExpr(expr)
    |   LOOKAHEAD(2)
        expr = inExpr(expr)
    |   expr = binaryEqualityExpr(expr)
    )* {
        return expr;
    }
}

Expression unaryEqualityExpr(Expression expr) :
{
    UnaryExpr.Operator op;
}
{
    (
        "ISNULL" {
            op = UnaryExpr.Operator.IS_NULL;
        }
    |   "NOTNULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    |   "NOT" "NULL" {
            op = UnaryExpr.Operator.NOT_NULL;
        }
    ) {
        return new UnaryExpr(new Block(expr.beginLine, expr.beginColumn,
            token.endLine, token.endColumn), op, expr);
    }
}

Expression binaryEqualityExpr(Expression left) :
{
    Expression right;
    BinaryExpr.Operator op;
}
{
    op = binaryEqualityOperator()
    right = relationalExpr() {
        return new BinaryExpr(new Block(left.beginLine, left.beginColumn,
            token.endLine, token.endColumn), left, right, op);
    }
}

BinaryExpr.Operator binaryEqualityOperator() :
{
}
{
    "=" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "==" {
        return BinaryExpr.Operator.EQUAL;
    }
|   "!=" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "<>" {
        return BinaryExpr.Operator.NOT_EQUAL;
    }
|   "IS"
    [
        "NOT" {
            return BinaryExpr.Operator.IS_NOT;
        }
    ] {
        return BinaryExpr.Operator.IS;
    }
|   "NOT"
    (
        "LIKE" {
            return BinaryExpr.Operator.NOT_LIKE;
        }
    |   "GLOB" {
            return BinaryExpr.Operator.NOT_GLOB;
        }
    |   "REGEXP" {
            return BinaryExpr.Operator.NOT_REGEXP;
        }
    |   "MATCH" {
            return BinaryExpr.Operator.NOT_MATCH;
        }
    )
|   "LIKE" {
        return BinaryExpr.Operator.LIKE;
    }
|   "GLOB" {
        return BinaryExpr.Operator.GLOB;
    }
|   "REGEXP" {
        return BinaryExpr.Operator.REGEXP;
    }
|   "MATCH" {
        return BinaryExpr.Operator.MATCH;
    }
}

BetweenExpr betweenExpr(Expression expr) :
{
    BetweenExpr between = new BetweenExpr();
    
    between.setExpression(expr);
    between.setBegin(expr);
}
{
    (
        "NOT" "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.NOT_BETWEEN);
        }
    |   "BETWEEN" {
            between.setOperator(BetweenExpr.Operator.BETWEEN);
        }
    )
    expr = relationalExpr() {
        between.setLower(expr);
    }
    "AND"
    expr = relationalExpr() {
        between.setUpper(expr);
        between.setEnd(token.endLine, token.endColumn);
        return between;
    }
}

InExpr inExpr(Expression expr) :
{
    InExpr in = null;
    InExpr.Operator op;
}
{
    (
        "NOT" "IN" {
            op = InExpr.Operator.NOT_IN;
        }
    |   "IN" {
            op = InExpr.Operator.IN;
        }
    )
    (
        "("
        [
            in = inSelectExpr()
        |   in = inSetExpr()
        ] {
            if (in == null) {
                in = new InSetExpr();
            }
        }
        ")"
    |   in = inTableExpr()
    ) {
        in.setExpression(expr);
        in.setOperator(op);
        in.setBegin(expr);
        in.setEnd(token.endLine, token.endColumn);
        return in;
    }
}

InSelectExpr inSelectExpr() :
{
    SelectStmt stmt;
}
{
    stmt = selectStmt() {
        InSelectExpr in = new InSelectExpr();
        in.setStatement(stmt);
        return in;
    }
}

InSetExpr inSetExpr() :
{
    InSetExpr in = new InSetExpr();
    Expression expr;
}
{
    expr = expr() {
        in.addExpression(expr);
    }
    (
        ","
        expr = expr() {
            in.addExpression(expr);
        }
    )* {
        return in;
    }
}

InTableExpr inTableExpr() :
{
    InTableExpr in = new InTableExpr();
    Name database = null;
    Name table;
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() {
            in.setDatabase(database);
        }
        "."
    ]
    table = name() {
        in.setTable(table);
        return in;
    }
}

Expression relationalExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = escapeExpr()
    (
        (
            "<" {
                op = BinaryExpr.Operator.LESS;
            }
        |   "<=" {
                op = BinaryExpr.Operator.LESS_OR_EQUAL;
            }
        |   ">" {
                op = BinaryExpr.Operator.GREATER;
            }
        |   ">=" {
                op = BinaryExpr.Operator.GREATER_OR_EQUAL;
            }
        )
        right = escapeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression escapeExpr() :
{
    Expression left;
    Expression right;
}
{
    left = bitwiseExpr()
    [
        "ESCAPE"
        right = bitwiseExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.ESCAPE);
        }
    ] {
        return left;
    }
}

Expression bitwiseExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = additiveExpr()
    (
        op = bitwiseOperator()
        right = additiveExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

BinaryExpr.Operator bitwiseOperator() :
{
}
{
    ">>" {
        return BinaryExpr.Operator.SHIFT_HIGH;
    }
|   "<<" {
        return BinaryExpr.Operator.SHIFT_LOW;
    }
|   "&" {
        return BinaryExpr.Operator.BIT_AND;
    }
|   "|" {
        return BinaryExpr.Operator.BIT_OR;
    }
}

Expression additiveExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = multiplicativeExpr()
    (
        (
            "+" {
                op = BinaryExpr.Operator.ADDITION;
            }
        |   "-" {
                op = BinaryExpr.Operator.SUBTRACTION;
            }
        )
        right = multiplicativeExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression multiplicativeExpr() :
{
    Expression left;
    Expression right;
    BinaryExpr.Operator op;
}
{
    left = concatenateExpr()
    (
        (
            "*" {
                op = BinaryExpr.Operator.MULTIPLICATION;
            }
        |   "/" {
                op = BinaryExpr.Operator.DIVISION;
            }
        |   "%" {
                op = BinaryExpr.Operator.MODULO;
            }
        )
        right = concatenateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right, op);
        }
    )* {
        return left;
    }
}

Expression concatenateExpr() :
{
    Expression left;
    Expression right;
}
{
    left = collateExpr()
    (
        "||"
        right = collateExpr() {
            left = new BinaryExpr(new Block(left.beginLine, left.beginColumn,
                token.endLine, token.endColumn), left, right,
                BinaryExpr.Operator.CONCATENATION);
        }
    )* {
        return left;
    }
}

Expression collateExpr() :
{
    Expression expr;
    Name collation;
}
{
    expr = unaryExpr()
    (
        "COLLATE"
        collation = name() {
            expr = new CollateExpr(new Block(expr.beginLine, expr.beginColumn,
                token.endLine, token.endColumn), expr, collation);
        }
    )* {
        return expr;
    }
}

Expression unaryExpr() :
{
    Expression expr;
    UnaryExpr.Operator op;
}
{
    (   
	    op = unaryOperator() {
	        int line = token.beginLine;
	        int column = token.beginColumn;
	    }
        expr = unaryExpr() {
            expr = new UnaryExpr(new Block(line, column, token.endLine,
                token.endColumn), op, expr);
        }
    |   expr = terminalExpr()
    ) {
        return expr;
    }
}

UnaryExpr.Operator unaryOperator() :
{
}
{
    "-" {
        return UnaryExpr.Operator.NEGATIVE;
    }
|   "+" {
        return UnaryExpr.Operator.POSITIVE;
    }
|   "~" {
        return UnaryExpr.Operator.BIT_NOT;
    }
}

Expression terminalExpr() :
{
    Expression expr;
}
{
    (
        expr = bindParameterExpr()
    |   LOOKAHEAD(2) // columnExpr also starts with a name.
        expr = functionExpr()
    |   LOOKAHEAD(2) // literalExpr may also start with a <STRING>.
        expr = columnExpr()
    |   expr = literalExpr()
    |   expr = castExpr()
    |   expr = existsExpr()
    |   LOOKAHEAD(2) // selectExpr also starts by "(".
        "(" expr = expr() ")"
    |   expr = selectExpr()
    |   expr = caseExpr()
    |   expr = raiseFunctionExpr()
    ) {
        return expr;
    }
}

LiteralExpr literalExpr() :
{
    Literal literal;
}
{
    literal = literalValue() {
        return new LiteralExpr(new Block(literal), literal);
    }
}

BindParameterExpr bindParameterExpr() :
{
}
{
    <PARAMETER> {
        return new BindParameterExpr(new Block(token.beginLine, 
            token.beginColumn, token.endLine, token.endColumn), token.image);
    }
}

FunctionExpr functionExpr() :
{
    FunctionExpr function = new FunctionExpr();
    Name name;
    Expression expr;
}
{
    name = name() {
        function.setFunction(name);
        function.setBegin(name);
    }
    "("
    [
        "*" {
            function.setOperator(FunctionExpr.Operator.UNIVERSAL);
        }
    |   [
            "DISTINCT" {
                function.setOperator(FunctionExpr.Operator.DISTINCT);
            }
        ]
        expr = expr() {
            function.addExpression(expr);
        }
        (
            ","
            expr = expr() {
                function.addExpression(expr);
            }
        )*
    ]
    ")" {
        function.setEnd(token.endLine, token.endColumn);
        return function;
    }
}

ColumnExpr columnExpr() :
{
    ColumnExpr reference = new ColumnExpr();
    Name database = null;
    Name table = null;
    Name column;
}
{
    (
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        [
            LOOKAHEAD(4) // Anticipate the occurrence of a dot.
            database = name() {
                reference.setBegin(database);
                reference.setDatabase(database);
            }
            "."
        ]
        table = name() {
            if (database == null) {
                reference.setBegin(table);
            }
            reference.setTable(table);
        }
        "."    
	    column = name() {
	        reference.setColumn(column);
	        return reference;
	    }
    |   <ID> {
            // In case ColumnExpr only has the column name, that can't be a
            // <STRING> because would exist a syntactic conflict with a string
            // literal.
            reference.setColumn(new Name(new Block(token.beginLine,
                token.beginColumn, token.endLine, token.endColumn),
                token.image));
        }
    ) {
        reference.setEnd(token.endLine, token.endColumn);
        return reference;
    }
}

CastExpr castExpr() :
{
    CastExpr cast = new CastExpr();
    Expression expr;
    TypeName type;
}
{
    "CAST" {
        cast.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    expr = expr() {
        cast.setExpression(expr);
    }
    "AS"
    type = typeName() {
        cast.setType(type);
    }
    ")" {
        cast.setEnd(token.endLine, token.endColumn);
        return cast;
    }
}

UnaryExpr existsExpr() :
{
    UnaryExpr exists = new UnaryExpr();
    Expression expr;
}
{
    "EXISTS" {
        exists.setBegin(token.beginLine, token.beginColumn);
    }
    expr = selectExpr() {
        exists.setExpression(expr);
        exists.setOperator(UnaryExpr.Operator.EXISTS);
        exists.setEnd(token.endLine, token.endColumn);
        return exists;
    }
}

SelectExpr selectExpr() :
{
    SelectExpr expr = new SelectExpr();
    SelectStmt stmt;
}
{
    "(" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt()
    ")" {
        expr.setStatement(stmt);
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

CaseExpr caseExpr() :
{
    CaseExpr caseExpr = new CaseExpr();
    Expression expr;
    WhenExpr when;
}
{
    "CASE" {
        caseExpr.setBegin(token.beginLine, token.beginColumn);
    }
    [
        expr = expr() {
            caseExpr.setCase(expr);
        }
    ]
    (
        when = whenExpr() {
            caseExpr.addWhen(when);
        }
    )+
    [
        "ELSE"
        expr = expr() {
            caseExpr.setElse(expr);
        }
    ]
    "END" {
        caseExpr.setEnd(token.endLine, token.endColumn);
        return caseExpr;
    }
}

WhenExpr whenExpr() :
{
    WhenExpr when = new WhenExpr();
    Expression expr;
}
{
    "WHEN" {
        when.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        when.setWhen(expr);
    }
    "THEN"
    expr = expr() {
        when.setThen(expr);
        when.setEnd(token.endLine, token.endColumn);
        return when;
    }
}

RaiseFunctionExpr raiseFunctionExpr() :
{
    RaiseFunctionExpr expr = new RaiseFunctionExpr();
}
{
    "RAISE" {
        expr.setBegin(token.beginLine, token.beginColumn);
    }
    "("
    (
        "IGNORE" {
            expr.setType(RaiseFunctionExpr.Type.IGNORE);
        }
    |   (
            "ROLLBACK" {
                expr.setType(RaiseFunctionExpr.Type.ROLLBACK);
            }
        |   "ABORT" {
                expr.setType(RaiseFunctionExpr.Type.ABORT);
            }
        |   "FAIL" {
                expr.setType(RaiseFunctionExpr.Type.FAIL);
            }
        )
        ","
        (
            <ID>
        |   <STRING>
        ) {
            expr.setError(token.image);
        }
    )
    ")" {
        expr.setEnd(token.endLine, token.endColumn);
        return expr;
    }
}

Literal literalValue() :
{
    Literal literal;
}
{
    (
        literal = numericLiteral()
    |   literal = stringLiteral()
    |   literal = blobLiteral()
    |   (
            "NULL"
        |   "CURRENT_TIME"
        |   "CURRENT_DATE"
        |   "CURRENT_TIMESTAMP"
        ) {
           literal = new Literal(new Block(token.beginLine, token.beginColumn,
               token.endLine, token.endColumn), token.image);
        }
    ) {
        return literal;
    }
}

NumericLiteral numericLiteral() :
{
}
{
    <NUMERIC> {
        return new NumericLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

StringLiteral stringLiteral() :
{
}
{
    <STRING> {
        return new StringLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

BlobLiteral blobLiteral() :
{
}
{
    <BLOB> {
        return new BlobLiteral(new Block(token.beginLine, token.beginColumn,
            token.endLine, token.endColumn), token.image);
    }
}

InsertStmt insertStmt() :
{
    InsertStmt stmt = new InsertStmtDefault();
    Name database = null;
    Name table;
    List<Name> columns = null;
}
{
    (
        "INSERT" {
            stmt.setBegin(token.beginLine, token.beginColumn);
            stmt.setType(InsertStmt.Type.INSERT);
        }
        [
            "OR"
            (
                "ROLLBACK" {
                    stmt.setType(InsertStmt.Type.INSERT_OR_ROLLBACK);
                }
            |   "ABORT" {
                    stmt.setType(InsertStmt.Type.INSERT_OR_ABORT);
                }
            |   "REPLACE" {
                    stmt.setType(InsertStmt.Type.INSERT_OR_REPLACE);
                }
            |   "FAIL" {
                    stmt.setType(InsertStmt.Type.INSERT_OR_FAIL);
                }
            |   "IGNORE" {
                    stmt.setType(InsertStmt.Type.INSERT_OR_IGNORE);
                }
            )
        ]
    |   "REPLACE" {
            stmt.setBegin(token.beginLine, token.beginColumn);
            stmt.setType(InsertStmt.Type.REPLACE);
        }
    )
    "INTO"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    table = name()
    (
        "DEFAULT" "VALUES"
    |   [
            "(" {
                Name column;
                columns = new LinkedList<Name>();
            }
            column = name() {
                columns.add(column);
            }
            (
                ","
	            column = name() {
	                columns.add(column);
	            }
            )*
            ")"
        ]
        (
            stmt = insertStmtWithValues(stmt, columns)
        |   stmt = insertStmtWithSelect(stmt, columns)
        )
    ) {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setDatabase(database);
        stmt.setTable(table);
        return stmt;
    }
}

InsertStmt insertStmtWithValues(InsertStmt stmt, List<Name> columns) :
{
    InsertStmtWithValues stmtWValues = new InsertStmtWithValues(stmt);
    Expression expr;

    stmtWValues.setColumns(columns);
}
{
    "VALUES"
    "("
    expr = expr() {
        stmtWValues.addValue(expr);
    }
    (
        ","
	    expr = expr() {
	        stmtWValues.addValue(expr);
	    }
    )*
    ")"
    (
        "," {
            stmtWValues.addRow();
        }
        "("
        expr = expr() {
	        stmtWValues.addValue(expr);
	    }
	    (
	        ","
	        expr = expr() {
	            stmtWValues.addValue(expr);
	        }
	    )*
        ")"
    )* {
        return stmtWValues;
    }
}
        
InsertStmt insertStmtWithSelect(InsertStmt stmt, List<Name> columns) :
{
    SelectStmt select;
}
{
    select = selectStmt() {
        InsertStmtWithSelect stmtWSelect = new InsertStmtWithSelect(stmt);
        stmtWSelect.setSelect(select);
        stmtWSelect.setColumns(columns);
        return stmtWSelect;
    }
}

PragmaStmt pragmaStmt() :
{
    PragmaStmt stmt = new PragmaStmt();
    Name database = null;
    Name pragma;
    PragmaValue value = null;
}
{
    "PRAGMA" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() "."
    ]
    pragma = name()
    [
        "="
        value = pragmaValue()
    |   "("
        value = pragmaValue()
        ")"
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setDatabase(database);
        stmt.setPragma(pragma);
        stmt.setValue(value);
        return stmt;
    }
}

PragmaValue pragmaValue() :
{
    UnaryExpr expr;
    StringLiteral literal;
    Name name;
}
{
    (
        expr = signedNumber() {
            return new PragmaNumber(expr, expr);
        }
    |   LOOKAHEAD(<STRING>) // name() that also can match <STRING>
        literal = stringLiteral() {
            return new PragmaString(literal, literal);
        }
    |   name = name() {
            return new PragmaName(name, name);
        }
	)
}

ReindexStmt reindexStmt() :
{
    ReindexStmt stmt = new ReindexStmt();
    Name first = null;
    Name second = null;
}
{
    "REINDEX" {
        stmt.setBegin(token.beginLine, token.beginColumn);
    }
    [
        first = name()
        [
            "."
            second = name()
        ]
    ] {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setFirst(first);
        stmt.setSecond(second);
        return stmt;
    }
}

SelectStmt selectStmt() :
{
    SelectStmt stmt = new SelectStmt();
    SelectUnit unit;
    SelectCompound.Operator op;
    SelectUnit core;
    EventConstraint constraint = null;
}
{
    unit = selectCore() {
        stmt.setBegin(unit);
    }
    (
        op = compoundOperator()
        core = selectCore() {
            unit = new SelectCompound(new Block(unit.beginLine, 
                unit.beginColumn, token.endLine, token.endColumn), unit, op,
                core);
        }
    )* {
    }
    constraint = eventConstraint() {
        stmt.setUnit(unit);
        stmt.setConstraint(constraint);
        stmt.setEnd(token.endLine, token.endColumn);
        return stmt;
    }
}

SelectCore selectCore() :
{
    SelectCore core = new SelectCore();
    ResultColumn column;}
{
    "SELECT" {
        core.setBegin(token.beginLine, token.beginColumn);
    }
    [
        "DISTINCT" {
            core.setDistinct(true);
        }
    |   "ALL"
    ]
    column = resultColumn() {
        core.addColumn(column);
    }
    (
        ","
        resultColumn() {
	        core.addColumn(column);
	    }
    )*
    [
        "FROM" {
            JoinSrc src;
        }
        src = joinSource() {
            core.setFrom(src);
        }
    ]
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            core.setWhere(expr);
        }
    ]
    [
        "GROUP" "BY" {
            Expression expr;
        }
        expr = expr() {
            core.addGroupByExpression(expr);
        }
        (
            ","
            expr = expr() {
                core.addGroupByExpression(expr);
            }
        )*
        [
            "HAVING"
            expr = expr() {
                core.setHaving(expr);
            }
        ]
    ] {
        core.setEnd(token.endLine, token.endColumn);
        return core;
    }
}

ResultColumn resultColumn() :
{
    ResultColumn column;}
{
    (
        LOOKAHEAD(3) // Removes ambiguity between "table.*" and "table.column".
        column = universalColumn()
    |   column = expressionColumn()
    ) {
        return column;
    }}

UniversalColumn universalColumn() :
{
    UniversalColumn column = new UniversalColumn();
    Name table;
}
{
    (
        "*" {
            column.setBeginEnd(token.beginLine, token.beginColumn,
                token.endLine, token.endColumn);
        }
    |   table = name() {
            column.setTable(table);
        }
        "." 
        "*" {
            column.setBeginEnd(table.beginLine, table.beginColumn, token.endLine,
                token.endColumn);
        }
    ) {
        return column;
    }
}

ExpressionColumn expressionColumn() :
{
    ExpressionColumn column = null;
    Expression expr;
}
{
    expr = expr()
    [
        column = aliasedColumn()
    ] {
        if (column == null) {
            column = new ExpressionColumn();
        }
        column.setExpression(expr);
        column.setBeginEnd(expr.beginLine, expr.beginColumn, token.endLine,
            token.endColumn);
        return column;
    }
}

AliasedColumn aliasedColumn() :
{
    AliasedColumn column = new AliasedColumn();
    Name alias;
}
{
	[ "AS" ]
	alias = name() {
	    column.setAlias(alias);
	    return column;
	}
}

JoinSrc joinSource() :
{
    JoinSrc src;
    JoinCompound.Operator op;
    JoinSrc right;
    JoinConstraint constraint;}
{
    src = singleSource()
    (
        op = joinOp()
        right = singleSource()
        constraint = joinConstraint() {
            src = new JoinCompound(new Block(src.beginLine, src.beginColumn,
                token.endLine, token.endColumn), src, op, right, constraint);
        }
    )* {
        return src;
    }}

JoinSrc singleSource() :
{
    JoinSrc src;
    int line = 0;
    int column = 0;}
{
    (
        src = tableSource()
    |   // To remove ambiguity between selectSource and the joinSource because 
        // both start by "(".
        LOOKAHEAD(2)
        src = selectSource()
    |   "(" {
            line = token.beginLine;
            column = token.beginColumn;
        }
        src = joinSource()
        ")" {
            src.setBeginEnd(line, column, token.endLine, token.endColumn);
        }
    ) {
        return src;
    }}

TableSrc tableSource() :
{
    TableSrc src = new TableSrc();
    Name database = null;
    Name table;
    IndexedBy indexed;
}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() {
            src.setDatabase(database);
            src.setBegin(database);
        }
        "."
    ]
    table = name() {
        src.setTable(table);
        if (database == null) {
            src.setBegin(table);
        }
    }
    [
        [ "AS" ] {
            Name alias;
        }
        alias = name() {
            src.setAlias(alias);
        }
    ]
    indexed = indexedBy() {
        src.setIndexed(indexed);
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

SelectSrc selectSource() :
{
    SelectSrc src = new SelectSrc();
    SelectStmt stmt;
}
{
    "(" {
        src.setBegin(token.beginLine, token.beginColumn);
    }
    stmt = selectStmt() {
        src.setSelect(stmt);
    }
    ")"
    [
        [ "AS" ] {
            Name alias;
        }
        alias = name() {
            src.setAlias(alias);
        }
    ] {
        src.setEnd(token.endLine, token.endColumn);
        return src;
    }
}

JoinCompound.Operator joinOp() :
{}
{
    "," {
        return JoinCompound.Operator.COMMA;
    }
|   "NATURAL" 
    (
        "LEFT" 
        (
            "OUTER" "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_OUTER_JOIN;	        }
	    |   "JOIN" {
	            return JoinCompound.Operator.NATURAL_LEFT_JOIN;
	        }
        )
    |   "INNER" "JOIN" {
            return JoinCompound.Operator.NATURAL_INNER_JOIN;
        }
    |   "CROSS" "JOIN" {
            return JoinCompound.Operator.NATURAL_CROSS_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.NATURAL_JOIN;
        }
    )
|   "LEFT" 
    (
        "OUTER" "JOIN" {
            return JoinCompound.Operator.LEFT_OUTER_JOIN;
        }
    |   "JOIN" {
            return JoinCompound.Operator.LEFT_JOIN;
        }
    )
|   "INNER" "JOIN" {
        return JoinCompound.Operator.INNER_JOIN;
    }
|   "CROSS" "JOIN" {
        return JoinCompound.Operator.CROSS_JOIN;
    }
|   "JOIN" {
        return JoinCompound.Operator.JOIN;
    }
}

JoinConstraint joinConstraint() :
{
    JoinConstraint constraint = null;}
{
    [
        constraint = joinConstraintOn()
    |   constraint = joinConstraintUsing()
    ] {
        return constraint;
    }}

JoinConstraintOn joinConstraintOn() :
{
    JoinConstraintOn constraint = new JoinConstraintOn();
    Expression expr;
}
{
    "ON" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
    expr = expr() {
        constraint.setExpression(expr);
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

JoinConstraintUsing joinConstraintUsing():
{
    JoinConstraintUsing constraint = new JoinConstraintUsing();
    Name column;
}
{
    "USING" {
        constraint.setBegin(token.beginLine, token.beginColumn);
    }
	"("
	column = name() {
        constraint.addColumn(column);
    }
    (
        ","
        column = name() {
            constraint.addColumn(column);
        }
    )*
    ")" {
        constraint.setEnd(token.endLine, token.endColumn);
        return constraint;
    }
}

OrderingTerm orderingTerm() :
{
    OrderingTerm term = new OrderingTerm();
    Expression expr;}
{
    expr = expr() {
        term.setBegin(expr);
        term.setExpression(expr);
    }
    [
        "ASC" {
            term.setOrder(OrderingTerm.Order.ASC);
        }
    |   "DESC" {
            term.setOrder(OrderingTerm.Order.DESC);
        }
    ] {
        term.setEnd(token.endLine, token.endColumn);
        return term;
    }}

SelectCompound.Operator compoundOperator() :
{
}
{
    "UNION" 
    [ 
        "ALL" {
            return SelectCompound.Operator.UNION_ALL;
        }
    ] {
        return SelectCompound.Operator.UNION;
    }
|   "INTERSECT" {
        return SelectCompound.Operator.INTERSECT;
    }
|   "EXCEPT" {
        return SelectCompound.Operator.EXCEPT;
    }
}

IndexedBy indexedBy() :
{
    IndexedBy indexed = new IndexedBy();
}
{
    [
	    (
	        "INDEXED" {
	            Name index;
	            indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "BY"
	        index = name() {
	            indexed.setIndex(index);
	        }
	    |   "NOT" {
                indexed.setBegin(token.beginLine, token.beginColumn);
            }
            "INDEXED"
	    ) {
            indexed.setEnd(token.endLine, token.endColumn);
            return indexed;
        }
    ] {
        return null;
    }
}

UpdateStmt updateStmt() :
{
    UpdateStmt stmt = new UpdateStmt();
    QualifiedTableName qualifiedTable;
    ColumnAssign assign;
    EventConstraint constraint = null;
}
{
    "UPDATE" {
        stmt.setBegin(token.beginLine, token.beginColumn);
        stmt.setType(UpdateStmt.Type.UPDATE);
    }
    [
        "OR"
        (
            "ROLLBACK" {
                stmt.setType(UpdateStmt.Type.UPDATE_OR_ROLLBACK);
            }
        |   "ABORT" {
                stmt.setType(UpdateStmt.Type.UPDATE_OR_ABORT);
            }
        |   "REPLACE" {
                stmt.setType(UpdateStmt.Type.UPDATE_OR_REPLACE);
            }
        |   "FAIL" {
                stmt.setType(UpdateStmt.Type.UPDATE_OR_FAIL);
            }
        |   "IGNORE" {
                stmt.setType(UpdateStmt.Type.UPDATE_OR_IGNORE);
            }
        )
    ]
    qualifiedTable = qualifiedTableName()
    "SET"
    assign = columnAssign() {
        stmt.addAssignment(assign);
    }
    (
        ","
	    assign = columnAssign() {
	        stmt.addAssignment(assign);
	    }
    )*
    [
        "WHERE" {
            Expression expr;
        }
        expr = expr() {
            stmt.setWhere(expr);
        }
    ]
    constraint = eventConstraint() {
        stmt.setEnd(token.endLine, token.endColumn);
        stmt.setQualifiedTable(qualifiedTable);
        stmt.setConstraint(constraint);
        return stmt;
    }
}

QualifiedTableName qualifiedTableName() :
{
    QualifiedTableName qualifiedTable = new QualifiedTableName();
    Name database = null;
    Name table;
    IndexedBy indexed;
}
{
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        database = name() {
            qualifiedTable.setBegin(database);
        }
        "."
    ]
    table = name() {
        if (database == null) {
            qualifiedTable.setBegin(table);
        }
    }
    indexed = indexedBy() {
        qualifiedTable.setEnd(token.endLine, token.endColumn);
        qualifiedTable.setDatabase(database);
        qualifiedTable.setTable(table);
        qualifiedTable.setIndexed(indexed);
        return qualifiedTable;
    }
}

ColumnAssign columnAssign() :
{
    Name column;
    Expression expr;
}
{
    column = name()
    "="
    expr = expr() {
        return new ColumnAssign(new Block(column.beginLine, column.beginColumn,
            token.endLine, token.endColumn), column, expr);
    }
}


VacuumStmt vacuumStmt() :
{
}
{
    "VACUUM" {
        VacuumStmt stmt = new VacuumStmt();
        stmt.setBeginEnd(token.beginLine, token.beginColumn, token.endLine,
            token.endColumn);
        return stmt;
    }
}